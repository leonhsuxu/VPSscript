name: TG频道抓取 → xiecang/speedtest-clash 测速（指定版本，无轮询）
on:
  schedule:
    - cron: '10 */4 * * *'      # 每4小时执行
  workflow_dispatch:
env:
  MIHOMO_VERSION: v1.19.17
  SPEEDTEST_VERSION: v0.3.12 # 请根据需要更新到您希望的版本，例如 v0.4.1
jobs:
  test-and-optimize:
    runs-on: ubuntu-latest
    timeout-minutes: 40
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install Python dependencies # 核心修复：安装 PyYAML 库
        run: |
          pip install PyYAML
          pip install -r requirements.txt # 如果您的TelegramNode脚本有requirements.txt文件，这会安装其依赖
      - name: Install yq
        run: |
          wget -qO yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x yq
          sudo mv yq /usr/local/bin/
      - name: Cache Mihomo
        id: cache-mihomo
        uses: actions/cache@v4
        with:
          path: mihomo
          key: mihomo-amd64-${{ env.MIHOMO_VERSION }}-${{ github.run_id }}
          restore-keys: mihomo-amd64-${{ env.MIHOMO_VERSION }}-
      - name: Download Mihomo 指定版本
        if: steps.cache-mihomo.outputs.cache-hit != 'true'
        run: |
          set -e
          TAG=${{ env.MIHOMO_VERSION }}
          echo "下载 Mihomo 版本: $TAG"
          URL="https://github.com/MetaCubeX/mihomo/releases/download/${TAG}/mihomo-linux-amd64-${TAG}.gz"
          echo "下载地址: $URL"
          curl --head --fail -s "$URL" || (echo "下载链接不可用，退出" && exit 1)
          wget --tries=5 --timeout=60 --progress=bar:force "$URL"
          gunzip "mihomo-linux-amd64-${TAG}.gz"
          mv "mihomo-linux-amd64-${TAG}" mihomo
          chmod +x mihomo
          ./mihomo -v
      - name: Cache xiecang speedtest-clash
        id: cache-xc
        uses: actions/cache@v4
        with:
          path: xcspeedtest
          key: xiecang-${{ env.SPEEDTEST_VERSION }}-${{ github.run_id }}
          restore-keys: xiecang-${{ env.SPEEDTEST_VERSION }}-
      - name: Download xiecang speedtest-clash
        if: steps.cache-xc.outputs.cache-hit != 'true'
        run: |
          set -e # 确保任何命令失败都会导致脚本退出
          RELEASE_TAG=${{ env.SPEEDTEST_VERSION }}
          echo "尝试下载 speedtest-clash 版本: $RELEASE_TAG"
          # 尝试从指定版本获取下载链接
          # 查找包含 "browser_download_url" 且资产名称中包含 "speedtest-clash_Linux_x86_64" 的链接
          URL=$(curl -s "https://api.github.com/repos/xiecang/speedtest-clash/releases/tags/${RELEASE_TAG}" \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          # 如果在指定版本中未能找到，则尝试从最新版本获取（保留原脚本的健壮性）
          if [ -z "$URL" ]; then
            echo "警告: 未在指定版本 ${RELEASE_TAG} 找到 speedtest-clash_Linux_x86_64 资产，尝试从最新版本获取。"
            URL=$(curl -s https://api.github.com/repos/xiecang/speedtest-clash/releases/latest \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          fi
          if [ -z "$URL" ]; then
            echo "错误: 未找到 speedtest-clash 的下载链接 (需要包含 speedtest-clash_Linux_x86_64)。请检查版本号或仓库。退出。"
            exit 1
          fi
          FILENAME=$(basename "$URL") # 获取下载文件名，例如 speedtest-clash_Linux_x86_64.tar.gz 或 speedtest-clash_Linux_x86_64
          echo "xiecang speedtest-clash 下载地址: $URL"
          echo "下载到文件: $FILENAME"
          wget --tries=5 --timeout=60 --progress=bar:force -O "${FILENAME}" "$URL"
          # 检查是否为 tar.gz 压缩包
          if [[ "$FILENAME" == *.tar.gz ]]; then
            echo "检测到 .tar.gz 压缩包，进行解压..."
            tar -xzf "${FILENAME}"
            # 假设解压后的二进制文件名为 'speedtest-clash'
            if [ -f "speedtest-clash" ]; then
              echo "找到解压后的二进制文件 'speedtest-clash'。"
              mv speedtest-clash xcspeedtest
            else
              echo "警告: 未在 .tar.gz 解压目录中找到 'speedtest-clash' 二进制文件。尝试查找其他可执行文件..."
              # 更通用的查找可执行文件的方法
              EXTRACTED_BINARY_PATH=$(find . -maxdepth 1 -type f -executable -name "speedtest-clash*" -print -quit)
              if [ -n "$EXTRACTED_BINARY_PATH" ]; then
                echo "找到可执行文件: $(basename "$EXTRACTED_BINARY_PATH")"
                mv "$EXTRACTED_BINARY_PATH" xcspeedtest
              else
                echo "错误: 未能在解压目录中找到任何 'speedtest-clash' 相关的可执行文件。退出。"
                exit 1
              fi
            fi
            rm "${FILENAME}" # 清理下载的压缩包
          else
            # 如果是直接的二进制文件
            echo "下载的是直接的二进制文件。"
            mv "${FILENAME}" xcspeedtest
          fi
          chmod +x xcspeedtest
          echo "xcspeedtest 下载并准备完成。"
          ./xcspeedtest --help | head -3
      - name: Run Telegram scraper
        env:
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_STRING_SESSION: ${{ secrets.TELEGRAM_STRING_SESSION }}
        run: |
          mkdir -p flclashyaml
          python TelegramNode/telegram_publiclink.py
      - name: Check scraped file
        run: |
          [ -s flclashyaml/Tg-node.yaml ] || (echo "Tg-node.yaml 为空或不存在" && exit 1)
      - name: Build full Clash config
        run: |
          cat > config.yaml <<'EOF'
          port: 7890
          socks-port: 7891
          allow-lan: false
          mode: rule
          log-level: info
          external-controller: 127.0.0.1:9090
          proxies: [] # Initialize proxies as an empty list
          proxy-groups:
            - name: 节点选择
              type: select
              proxies: [DIRECT]
            - name: 自动选择
              type: url-test
              url: http://www.gstatic.com/generate_204
              interval: 300
              proxies: [DIRECT]
          rules:
            - MATCH,节点选择
          EOF

          # --- 核心修复：处理 Tg-node.yaml 的内容，确保其为 YAML 列表 ---
          if [ -s flclashyaml/Tg-node.yaml ]; then
            python -c "
import yaml
import sys
try:
    with open('flclashyaml/Tg-node.yaml', 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    if data is None: # 文件内容为空
        proxies_to_add = []
    elif isinstance(data, dict): # 如果是单个字典（单个代理），将其包装成列表
        proxies_to_add = [data]
    elif isinstance(data, list): # 如果已经是列表，直接使用
        proxies_to_add = data
    else: #  unexpected format
        print('Warning: Tg-node.yaml contained unexpected data type, treating as empty list.', file=sys.stderr)
        proxies_to_add = []
    with open('flclashyaml/Tg-node_processed.yaml', 'w', encoding='utf-8') as f_out:
        yaml.dump(proxies_to_add, f_out, allow_unicode=True, sort_keys=False)
except Exception as e:
    print(f'Error processing Tg-node.yaml: {e}', file=sys.stderr)
    # 出现任何异常时，也确保输出一个空列表
    with open('flclashyaml/Tg-node_processed.yaml', 'w', encoding='utf-8') as f_out:
        yaml.dump([], f_out)
"
            # 现在，将经过处理（保证是列表）的代理配置加载到 config.yaml 的 proxies 部分
            yq e '.proxies = load("flclashyaml/Tg-node_processed.yaml")' -i config.yaml
          else
            echo "flclashyaml/Tg-node.yaml 是空的或不存在，'proxies' 将保持为空列表。"
            # 此时 config.yaml 中的 proxies 已经初始化为 []，无需额外操作。
          fi

          # 现在 config.yaml 中的 'proxies' 保证是合法的 YAML 列表。
          # 接下来，安全地提取代理名称。
          # 'select(. != null)' 用于过滤掉任何可能的空名称或无效项。
          NAMES=$(yq e '.proxies[].name | select(. != null)' config.yaml | sed 's/^/  - /')
          
          if [ -z "$NAMES" ]; then
            echo "警告: 没有从代理列表中提取到任何代理名称，proxy-groups 的 'proxies' 键将只包含 [DIRECT]。"
            # 如果没有提取到任何名称，确保 proxy-groups 的 proxies 列表中只包含 DIRECT。
            yq e '.proxy-groups[] |= .proxies = ["DIRECT"]' -i config.yaml
          else
            # 创建一个临时 YAML 文件，包含提取到的代理名称（已格式化为列表项）。
            echo "$NAMES" > /tmp/extracted_proxy_names.yaml
            # 将这些名称追加到每个 proxy-group 的 'proxies' 列表中。
            yq e '.proxy-groups[] |= .proxies += load("/tmp/extracted_proxy_names.yaml")' -i config.yaml
            rm /tmp/extracted_proxy_names.yaml # 清理临时文件
          fi
      - name: Debug - Show generated configs # 调试步骤，检查最终配置
        run: |
          echo "--- Content of flclashyaml/Tg-node.yaml (original) ---"
          cat flclashyaml/Tg-node.yaml || echo "flclashyaml/Tg-node.yaml not found or empty."
          echo "--- End of flclashyaml/Tg-node.yaml (original) ---"
          echo "--- Content of flclashyaml/Tg-node_processed.yaml ---"
          cat flclashyaml/Tg-node_processed.yaml || echo "flclashyaml/Tg-node_processed.yaml not found or empty."
          echo "--- End of flclashyaml/Tg-node_processed.yaml ---"
          echo "--- Content of config.yaml (final) ---"
          cat config.yaml || echo "config.yaml not found or empty."
          echo "--- End of config.yaml (final) ---"
      - name: Start Mihomo
        run: |
          # 启动 Mihomo，并将所有输出重定向到 mihomo.log
          nohup ./mihomo -f config.yaml -d . > mihomo.log 2>&1 &
          
          # 等待 Mihomo 启动
          for i in {1..20}; do
            curl -s http://127.0.0.1:9090/proxies >/dev/null && break
            echo "等待 Mihomo 启动... ($i/20)"
            sleep 2
          done
          
          # 检查 Mihomo 是否成功启动，如果失败则打印日志并退出
          if ! curl -s http://127.0.0.1:9090/proxies >/dev/null; then
            echo "Mihomo 启动失败"
            echo "--- Mihomo Log ---"
            cat mihomo.log # 打印 Mihomo 的日志内容
            echo "--- End Mihomo Log ---"
            exit 1
          else
            echo "Mihomo 成功启动。"
          fi
      - name: Run xiecang speedtest-clash 测速
        run: |
          ./xcspeedtest --clash-api http://127.0.0.1:9090 --test-target google --timeout 12s --threads 10 --output results.txt
          cat results.txt
      - name: Generate optimized config
        run: |
          python <<'PY'
          import yaml, re
          results = []
          with open('results.txt', encoding='utf-8') as f:
              for line in f:
                  m = re.search(r'\[(.*?)\]\s+\((.*?)\):\s+(\d+)ms\s+(Success|Timeout|Error)', line)
                  if m:
                      results.append({'name': m.group(1), 'latency': int(m.group(3)), 'status': m.group(4)})
          good = sorted([r for r in results if r['status']=='Success' and r['latency']<800], key=lambda x: x['latency'])
          good_names = [x['name'] for x in good]
          with open('config.yaml', encoding='utf-8') as f:
              cfg = yaml.safe_load(f)
          cfg['proxies'] = [p for p in cfg['proxies'] if p['name'] in good_names]
          for g in cfg.get('proxy-groups', []):
              if g['type'] in ('select', 'url-test'):
                  g['proxies'] = ['DIRECT'] + good_names
          if not good_names:
              for g in cfg.get('proxy-groups', []):
                  if g['type'] in ('select', 'url-test'):
                      g['proxies'] = ['DIRECT']
          with open('flclashyaml/Tg-node-optimized.yaml', 'w', encoding='utf-8') as f:
              yaml.dump(cfg, f, allow_unicode=True, sort_keys=False)
          print(f"生成优质节点 {len(good_names)} 个")
          PY
      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add flclashyaml/Tg-node-optimized.yaml
          git diff --quiet --staged || git commit -m "Auto: 更新优化节点 $(date -u +%F_%H-%M)"
          git push || echo "无变化"
