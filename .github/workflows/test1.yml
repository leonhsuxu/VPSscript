name: TG频道抓取 → xiecang/speedtest-clash 测速（指定版本，无轮询）
on:
  schedule:
    - cron: '10 */4 * * *'      # 每4小时执行
  workflow_dispatch:
env:
  MIHOMO_VERSION: v1.19.17
  SPEEDTEST_VERSION: v0.3.12 # 请根据需要更新到您希望的版本，例如 v0.4.1
jobs:
  test-and-optimize:
    runs-on: ubuntu-latest
    timeout-minutes: 40
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install Python dependencies # 核心修复：安装 PyYAML 库
        run: |
          pip install PyYAML
          pip install -r requirements.txt # 如果您的TelegramNode脚本有requirements.txt文件，这会安装其依赖
      - name: Install yq
        run: |
          wget -qO yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x yq
          sudo mv yq /usr/local/bin/
      - name: Cache Mihomo
        id: cache-mihomo
        uses: actions/cache@v4
        with:
          path: mihomo
          key: mihomo-amd64-${{ env.MIHOMO_VERSION }}-${{ github.run_id }}
          restore-keys: mihomo-amd64-${{ env.MIHOMO_VERSION }}-
      - name: Download Mihomo 指定版本
        if: steps.cache-mihomo.outputs.cache-hit != 'true'
        run: |
          set -e
          TAG=${{ env.MIHOMO_VERSION }}
          echo "下载 Mihomo 版本: $TAG"
          URL="https://github.com/MetaCubeX/mihomo/releases/download/${TAG}/mihomo-linux-amd64-${TAG}.gz"
          echo "下载地址: $URL"
          curl --head --fail -s "$URL" || (echo "下载链接不可用，退出" && exit 1)
          wget --tries=5 --timeout=60 --progress=bar:force "$URL"
          gunzip "mihomo-linux-amd64-${TAG}.gz"
          mv "mihomo-linux-amd64-${TAG}" mihomo
          chmod +x mihomo
          ./mihomo -v
      - name: Cache xiecang speedtest-clash
        id: cache-xc
        uses: actions/cache@v4
        with:
          path: xcspeedtest
          key: xiecang-${{ env.SPEEDTEST_VERSION }}-${{ github.run_id }}
          restore-keys: xiecang-${{ env.SPEEDTEST_VERSION }}-
      - name: Download xiecang speedtest-clash
        if: steps.cache-xc.outputs.cache-hit != 'true'
        run: |
          set -e # 确保任何命令失败都会导致脚本退出
          RELEASE_TAG=${{ env.SPEEDTEST_VERSION }}
          echo "尝试下载 speedtest-clash 版本: $RELEASE_TAG"
          # 尝试从指定版本获取下载链接
          # 查找包含 "browser_download_url" 且资产名称中包含 "speedtest-clash_Linux_x86_64" 的链接
          URL=$(curl -s "https://api.github.com/repos/xiecang/speedtest-clash/releases/tags/${RELEASE_TAG}" \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          # 如果在指定版本中未能找到，则尝试从最新版本获取（保留原脚本的健壮性）
          if [ -z "$URL" ]; then
            echo "警告: 未在指定版本 ${RELEASE_TAG} 找到 speedtest-clash_Linux_x86_64 资产，尝试从最新版本获取。"
            URL=$(curl -s https://api.github.com/repos/xiecang/speedtest-clash/releases/latest \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          fi
          if [ -z "$URL" ]; then
            echo "错误: 未找到 speedtest-clash 的下载链接 (需要包含 speedtest-clash_Linux_x86_64)。请检查版本号或仓库。退出。"
            exit 1
          fi
          FILENAME=$(basename "$URL") # 获取下载文件名，例如 speedtest-clash_Linux_x86_64.tar.gz 或 speedtest-clash_Linux_x86_64
          echo "xiecang speedtest-clash 下载地址: $URL"
          echo "下载到文件: $FILENAME"
          wget --tries=5 --timeout=60 --progress=bar:force -O "${FILENAME}" "$URL"
          # 检查是否为 tar.gz 压缩包
          if [[ "$FILENAME" == *.tar.gz ]]; then
            echo "检测到 .tar.gz 压缩包，进行解压..."
            tar -xzf "${FILENAME}"
            # 假设解压后的二进制文件名为 'speedtest-clash'
            if [ -f "speedtest-clash" ]; then
              echo "找到解压后的二进制文件 'speedtest-clash'。"
              mv speedtest-clash xcspeedtest
            else
              echo "警告: 未在 .tar.gz 解压目录中找到 'speedtest-clash' 二进制文件。尝试查找其他可执行文件..."
              # 更通用的查找可执行文件的方法
              EXTRACTED_BINARY_PATH=$(find . -maxdepth 1 -type f -executable -name "speedtest-clash*" -print -quit)
              if [ -n "$EXTRACTED_BINARY_PATH" ]; then
                echo "找到可执行文件: $(basename "$EXTRACTED_BINARY_PATH")"
                mv "$EXTRACTED_BINARY_PATH" xcspeedtest
              else
                echo "错误: 未能在解压目录中找到任何 'speedtest-clash' 相关的可执行文件。退出。"
                exit 1
              fi
            fi
            rm "${FILENAME}" # 清理下载的压缩包
          else
            # 如果是直接的二进制文件
            echo "下载的是直接的二进制文件。"
            mv "${FILENAME}" xcspeedtest
          fi
          chmod +x xcspeedtest
          echo "xcspeedtest 下载并准备完成。"
          ./xcspeedtest --help | head -3
      - name: Run Telegram scraper
        env:
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_STRING_SESSION: ${{ secrets.TELEGRAM_STRING_SESSION }}
        run: |
          mkdir -p flclashyaml
          python TelegramNode/telegram_publiclink.py
      - name: Check scraped file
        run: |
          [ -s flclashyaml/Tg-node.yaml ] || (echo "Tg-node.yaml 为空或不存在" && exit 1)
      - name: Build full Clash config
        run: |
          cat > config.yaml <<'EOF'
          port: 7890
          socks-port: 7891
          allow-lan: false
          mode: rule
          log-level: info
          external-controller: 127.0.0.1:9090
          proxies: [] # Initialize proxies as an empty list
          proxy-groups:
            - name: 节点选择
              type: select
              proxies: [DIRECT]
            - name: 自动选择
              type: url-test
              url: http://www.gstatic.com/generate_204
              interval: 300
              proxies: [DIRECT]
          rules:
            - MATCH,节点选择
          EOF

          # --- 核心修复：处理 Tg-node.yaml 的内容，确保其为 YAML 列表 ---
          if [ -s flclashyaml/Tg-node.yaml ]; then
            python <<'EOPY'
              import yaml
              import sys
              try:
                  with open('flclashyaml/Tg-node.yaml', 'r', encoding='utf-8') as f:
                      data = yaml.safe_load(f)
                  if data is None: # 文件内容为空
                      proxies_to_add = []
                  elif isinstance(data, dict): # 如果是单个字典（单个代理），将其包装成列表
                      proxies_to_add = [data]
                  elif isinstance(data, list): # 如果已经是列表，直接使用
                      proxies_to_add = data
                  else: #  unexpected format
                      print('Warning: Tg-node.yaml contained unexpected data type, treating as empty list.', file=sys.stderr)
                      proxies_to_add = []
                  with open('flcl
