name: TG频道和群抓取节点测速 XC-speedtest测速版

# ==================== 触发条件配置 ====================
on:
  # 定时执行配置
  schedule:
    # 每4小时执行一次，整点后的10分钟执行（例如：00:10, 04:10, 08:10...）
    - cron: '10 */4 * * *'
  # 支持手动触发工作流
  workflow_dispatch:
    inputs:
      # 网络配置模式选择
      warp_config:
        description: '选择网络配置模式'
        required: false
        default: 'default'
        type: choice
        options:
          - default
          - all_warp
          - all_github
          - test_mode
      # 是否强制重新下载工具
      force_download:
        description: '强制重新下载工具（忽略缓存）'
        required: false
        default: false
        type: boolean
      # 测速模式选择
      speedtest_mode:
        description: '选择测速模式'
        required: false
        default: 'tcp_first'
        type: choice
        options:
          - tcp_first
          - tcp_only
          - clash_only
          - clash_first

# ==================== 环境变量配置 ====================
env:
  # ==================== 版本配置 ====================
  MIHOMO_VERSION: v1.19.17           # Mihomo (Clash Meta) 版本
  SPEEDTEST_VERSION: v0.4.1          # XC Speedtest 版本
  WGCF_VERSION: v2.2.29              # WGCF (Cloudflare Warp) 版本
  
  # ==================== 网络控制配置 默认网络配置====================
  # 这些变量是Python脚本的唯一控制源，控制各阶段是否使用Warp网络
  # true=使用Warp网络，false=使用原始GitHub网络
  
  # 抓取阶段：使用GitHub网络（速度快）
  WARP_FOR_SCRAPING: "false"
  # TCP测速阶段：使用Warp网络（模拟国内环境，测速结果更准确）
  WARP_FOR_TCP: "true"
  # Speedtest测速阶段：使用Warp网络（模拟国内环境，测速结果更准确）
  WARP_FOR_SPEEDTEST: "false"
  # 最终处理阶段：使用GitHub网络（确保提交等操作正常）
  WARP_FOR_FINAL: "false"
  
  # ==================== 测速策略配置 ====================
  # 测速模式选项：
  #   "tcp_only"      → 只用 TCP 测速（最快，最严格，适合节点特别多的情况）
  #   "clash_only"    → 只用 Speedtest-clash 测速（最准）
  #   "tcp_first"     → 先 TCP 粗筛（<800ms）→ 再 Speedtest 精测（推荐！平衡速度与质量）
  #   "clash_first"   → 先 Speedtest → 再 TCP（一般用不上）
  SPEEDTEST_MODE: "tcp_first"
  
  # ==================== 带宽筛选配置 ====================
  # 是否启用带宽筛选（True=启用，False=关闭）
  ENABLE_BANDWIDTH_FILTER: "true"
  # 最低带宽阈值（单位：MB/s）
  # 支持环境变量设置，例如在 GitHub Actions 里这样写：
  # ENABLE_BANDWIDTH_FILTER=true
  # MIN_BANDWIDTH_MB=30
  MIN_BANDWIDTH_MB: "20"
  
  # ==================== 日志配置 ====================
  # 是否启用TCP测速详细日志（生产环境建议关闭）
  ENABLE_TCP_LOG: "false"
  # 是否启用Speedtest测速详细日志（生产环境建议关闭）
  ENABLE_SPEEDTEST_LOG: "true"
  
  # ==================== Telegram频道配置 ====================
  # 要抓取的Telegram频道列表（每行一个）
  # 支持频道ID（如 @channel_name）或频道链接
  TELEGRAM_CHANNEL_IDS: |
    @fqDINYUE
    @wxdy666
    @freeyule
    @ccbaohe
    @duangvpsfs
    @zzzjjjkkkoi
    @xmdexw
    @v2v2clash
    @dingyue_Center
    @tempssrlink
    @sorenab2
    @proxyshareCN

# ==================== 工作流任务定义 ====================
jobs:
  # 主构建任务
  build:
    # 使用最新的Ubuntu运行器
    runs-on: ubuntu-latest
    # 设置任务超时时间（单位：分钟）
    timeout-minutes: 30
    # 任务步骤定义
    steps:
      # ==================== 步骤1：检出代码仓库 ====================
      - name: 检出代码仓库
        uses: actions/checkout@v4
        with:
          # 获取完整的历史记录，便于后续的提交操作
          fetch-depth: 0
          # 使用GitHub Token进行认证
          token: ${{ secrets.GITHUB_TOKEN }}
          # 是否检出子模块
          submodules: false
      
      # ==================== 步骤2：设置Python环境 ====================
      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          # 指定Python版本（3.11）
          python-version: '3.11'
          # 启用缓存以加速依赖安装
          cache: 'pip'
          # 缓存依赖文件路径
          cache-dependency-path: '**/requirements.txt'
      
      # ==================== 步骤3：缓存Python依赖 ====================
      - name: 缓存 Python 依赖
        uses: actions/cache@v4
        id: cache-pip
        with:
          # 缓存pip安装包的位置
          path: ~/.cache/pip
          # 缓存的唯一标识键，基于requirements.txt的哈希值
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          # 如果没有完全匹配的缓存，尝试恢复最接近的缓存
          restore-keys: |
            ${{ runner.os }}-pip-
      
      # ==================== 步骤4：安装Python依赖及系统依赖 ====================
      - name: 安装 Python 依赖及系统依赖
        run: |
          # 升级pip到最新版本
          python -m pip install --upgrade pip
          # 安装requirements.txt中指定的Python包
          pip install -r requirements.txt
          # 更新系统包列表（静默模式）
          sudo apt-get update -qq
          # 安装必要的系统工具
          sudo apt-get install -y \
            wireguard-tools \
            curl \
            resolvconf \
            wget
      
      # ==================== 步骤5：缓存Mihomo程序 ====================
      - name: 缓存 Mihomo 程序
        id: cache-mihomo
        uses: actions/cache@v4
        with:
          # 缓存Mihomo二进制文件
          path: mihomo
          # 缓存键：基于架构和版本
          key: mihomo-amd64-${{ env.MIHOMO_VERSION }}
          # 恢复键：相同架构的不同版本
          restore-keys: mihomo-amd64-${{ env.MIHOMO_VERSION }}
      
      # ==================== 步骤6：下载Mihomo指定版本 ====================
      - name: 下载 Mihomo 指定版本
        if: steps.cache-mihomo.outputs.cache-hit != 'true' || inputs.force_download == true
        run: |
          set -e
          TAG=${{ env.MIHOMO_VERSION }}
          URL="https://github.com/MetaCubeX/mihomo/releases/download/${TAG}/mihomo-linux-amd64-${TAG}.gz"
          echo "尝试访问下载链接: $URL"
          if ! curl --head --fail "$URL"; then
            echo "❌ 错误：下载地址不可用！"
            exit 1
          fi
          wget --tries=3 --timeout=30 -O mihomo.gz "$URL"
          gunzip -f mihomo.gz
          chmod +x mihomo
          ./mihomo -v
      
      # ==================== 步骤7：缓存wgcf工具 ====================
      - name: 缓存 wgcf 工具
        id: cache-wgcf
        uses: actions/cache@v4
        with:
          # 缓存wgcf二进制文件
          path: wgcf
          # 缓存键：基于架构和版本
          key: wgcf-linux-amd64-${{ env.WGCF_VERSION }}
          # 恢复键
          restore-keys: wgcf-linux-amd64-${{ env.WGCF_VERSION }}
      
      # ==================== 步骤8：下载wgcf工具 ====================
      - name: 下载 wgcf 工具
        if: steps.cache-wgcf.outputs.cache-hit != 'true' || inputs.force_download == true
        run: |
          WGCF_FULL_VERSION="${{ env.WGCF_VERSION }}"
          WGCF_FILENAME_VERSION="${WGCF_FULL_VERSION#v}"
          echo "正在下载 wgcf v${WGCF_FILENAME_VERSION}..."
          curl -fsSL -o wgcf "https://github.com/ViRb3/wgcf/releases/download/${WGCF_FULL_VERSION}/wgcf_${WGCF_FILENAME_VERSION}_linux_amd64"
          if [ ! -f "wgcf" ]; then
            echo "❌ 错误：wgcf 下载失败！"
            exit 1
          fi
          chmod +x wgcf
          echo "wgcf 下载完成。"
      
      # ==================== 步骤9：缓存speedtest-clash程序 ====================
      - name: 缓存 xiecang speedtest-clash
        id: cache-xc
        uses: actions/cache@v4
        with:
          # 缓存speedtest-clash二进制文件
          path: xcspeedtest
          # 缓存键：基于版本
          key: xiecang-${{ env.SPEEDTEST_VERSION }}
          # 恢复键
          restore-keys: xiecang-${{ env.SPEEDTEST_VERSION }}
      
      # ==================== 步骤10：下载speedtest-clash指定版本 ====================
      - name: 下载 xiecang speedtest-clash
        if: steps.cache-xc.outputs.cache-hit != 'true' || inputs.force_download == true
        run: |
          set -e
          RELEASE_TAG=${{ env.SPEEDTEST_VERSION }}
          echo "尝试下载 speedtest-clash 版本: $RELEASE_TAG"
          URL=$(curl -s "https://api.github.com/repos/xiecang/speedtest-clash/releases/tags/${RELEASE_TAG}" \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          if [ -z "$URL" ]; then
            echo "⚠️ 警告: 未找到指定版本 (${RELEASE_TAG})，尝试使用最新版本。"
            URL=$(curl -s https://api.github.com/repos/xiecang/speedtest-clash/releases/latest \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          fi
          if [ -z "$URL" ]; then
            echo "❌ 错误：未能找到 speedtest-clash 下载 URL，退出。"
            exit 1
          fi
          wget --tries=5 --timeout=60 -O downloaded_file "$URL"
          if file downloaded_file | grep -q "gzip compressed data"; then
            echo "检测到压缩包，开始解压"
            tar -xzf downloaded_file
            if [ -f "speedtest-clash" ]; then
              mv speedtest-clash xcspeedtest
            else
              EXE_PATH=$(find . -maxdepth 1 -type f -executable -name "speedtest-clash*" -print -quit)
              if [ -n "$EXE_PATH" ]; then
                mv "$EXE_PATH" xcspeedtest
              else
                echo "❌ 错误：未找到 speedtest-clash 可执行文件"
                exit 1
              fi
            fi
            rm downloaded_file
          else
            echo "下载的是可执行文件，直接重命名为 xcspeedtest"
            mv downloaded_file xcspeedtest
          fi
          chmod +x xcspeedtest
          ./xcspeedtest --help
      
      # ==================== 步骤11：智能网络配置 + 运行测速脚本 ====================
      - name: 智能网络配置 + 运行测速脚本
        env:
          # Telegram API 凭证
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_STRING_SESSION: ${{ secrets.TELEGRAM_STRING_SESSION }}
          # 其他环境变量
          GITHUB_ACTIONS: "true"
          PYTHONUNBUFFERED: "1"
        run: |
          # ============ 智能网络配置 ============
          echo "=== 🌐 智能网络配置 ==="
          
          # 初始化默认值
          WARP_FOR_SCRAPING="${{ env.WARP_FOR_SCRAPING }}"
          WARP_FOR_TCP="${{ env.WARP_FOR_TCP }}"
          WARP_FOR_SPEEDTEST="${{ env.WARP_FOR_SPEEDTEST }}"
          WARP_FOR_FINAL="${{ env.WARP_FOR_FINAL }}"
          SPEEDTEST_MODE="${{ env.SPEEDTEST_MODE }}"
          TELEGRAM_CHANNEL_IDS="${{ env.TELEGRAM_CHANNEL_IDS }}"
          
          # 手动触发时根据输入调整配置
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "手动触发工作流，网络配置模式: ${{ inputs.warp_config }}"
            
            case "${{ inputs.warp_config }}" in
              all_warp)
                echo "✅ 全流程使用Warp网络"
                WARP_FOR_SCRAPING="true"
                WARP_FOR_TCP="true"
                WARP_FOR_SPEEDTEST="true"
                WARP_FOR_FINAL="true"
                ;;
              all_github)
                echo "✅ 全流程使用GitHub网络"
                WARP_FOR_SCRAPING="false"
                WARP_FOR_TCP="false"
                WARP_FOR_SPEEDTEST="false"
                WARP_FOR_FINAL="false"
                ;;
              test_mode)
                echo "✅ 测试模式：仅抓取部分频道，使用Warp测速"
                TELEGRAM_CHANNEL_IDS="@fqDINYUE"
                WARP_FOR_SCRAPING="false"
                WARP_FOR_TCP="true"
                WARP_FOR_SPEEDTEST="true"
                WARP_FOR_FINAL="false"
                ;;
              *)
                echo "✅ 使用默认网络配置"
                ;;
            esac
            
            # 如果指定了测速模式，覆盖默认值
            if [ -n "${{ inputs.speedtest_mode }}" ]; then
              SPEEDTEST_MODE="${{ inputs.speedtest_mode }}"
              echo "✅ 测速模式覆盖为: ${{ inputs.speedtest_mode }}"
            fi
          else
            echo "✅ 定时触发，使用默认网络配置"
          fi
          
          # 显示最终配置
          echo ""
          echo "📋 最终执行配置："
          echo "--------------------------------------------------"
          echo "网络配置："
          echo "  - 抓取阶段 Warp: ${WARP_FOR_SCRAPING}"
          echo "  - TCP测速 Warp: ${WARP_FOR_TCP}"
          echo "  - Speedtest测速 Warp: ${WARP_FOR_SPEEDTEST}"
          echo "  - 最终阶段 Warp: ${WARP_FOR_FINAL}"
          echo ""
          echo "测速配置："
          echo "  - 测速模式: ${SPEEDTEST_MODE}"
          echo "  - 带宽筛选: ${{ env.ENABLE_BANDWIDTH_FILTER }} (≥${{ env.MIN_BANDWIDTH_MB }}MB/s)"
          echo "  - TCP日志: ${{ env.ENABLE_TCP_LOG }}"
          echo "  - Speedtest日志: ${{ env.ENABLE_SPEEDTEST_LOG }}"
          echo "--------------------------------------------------"
          echo "=== ✅ 网络配置完成 ==="
          
          # ============ 执行Python脚本 ============
          mkdir -p flclashyaml
          echo ""
          echo "=== 🚀 开始执行节点抓取和测速 ==="
          echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo ""
          echo "📊 执行参数汇总:"
          echo "--------------------------------------------------"
          echo "网络配置："
          echo "  📡 抓取阶段: $( [ "$WARP_FOR_SCRAPING" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo "  🚀 TCP测速: $( [ "$WARP_FOR_TCP" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo "  ⚡ Speedtest: $( [ "$WARP_FOR_SPEEDTEST" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo "  📝 最终处理: $( [ "$WARP_FOR_FINAL" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo ""
          echo "测速配置："
          echo "  🎯 测速模式: ${SPEEDTEST_MODE}"
          echo "  📶 带宽筛选: $( [ "${{ env.ENABLE_BANDWIDTH_FILTER }}" = "true" ] && echo "启用 (≥${{ env.MIN_BANDWIDTH_MB }}MB/s)" || echo "关闭" )"
          echo "  📋 日志级别: TCP=${{ env.ENABLE_TCP_LOG }}, Speedtest=${{ env.ENABLE_SPEEDTEST_LOG }}"
          echo "--------------------------------------------------"
          echo ""
          echo "▶️ 开始执行Python脚本..."
          echo "--------------------------------------------------"
          
          # 关键：直接在环境中传递配置给Python脚本
          WARP_FOR_SCRAPING="${WARP_FOR_SCRAPING}" \
          WARP_FOR_TCP="${WARP_FOR_TCP}" \
          WARP_FOR_SPEEDTEST="${WARP_FOR_SPEEDTEST}" \
          WARP_FOR_FINAL="${WARP_FOR_FINAL}" \
          SPEEDTEST_MODE="${SPEEDTEST_MODE}" \
          TELEGRAM_CHANNEL_IDS="${TELEGRAM_CHANNEL_IDS}" \
          ENABLE_BANDWIDTH_FILTER="${{ env.ENABLE_BANDWIDTH_FILTER }}" \
          MIN_BANDWIDTH_MB="${{ env.MIN_BANDWIDTH_MB }}" \
          ENABLE_TCP_LOG="${{ env.ENABLE_TCP_LOG }}" \
          ENABLE_SPEEDTEST_LOG="${{ env.ENABLE_SPEEDTEST_LOG }}" \
          python TelegramNode/TBD-telegram_publiclink.py
          
          EXIT_CODE=$?
          echo ""
          echo "--------------------------------------------------"
          if [ $EXIT_CODE -eq 0 ]; then
            echo "✅ 节点抓取和测速完成"
            if [ -f "flclashyaml/Tg-node1.yaml" ]; then
              FILE_SIZE=$(stat -c%s "flclashyaml/Tg-node1.yaml" 2>/dev/null || stat -f%z "flclashyaml/Tg-node1.yaml" 2>/dev/null || echo "unknown")
              echo "📁 配置文件生成成功: flclashyaml/Tg-node1.yaml (${FILE_SIZE} bytes)"
            else
              echo "⚠️  配置文件未生成"
            fi
          else
            echo "❌ Python脚本执行失败，退出码: $EXIT_CODE"
            exit $EXIT_CODE
          fi
          echo ""
          echo "结束时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo "=== ✅ 脚本执行完成 ==="
      
      # ==================== 步骤12：确保网络正常（重要修复） ====================
      - name: 确保网络正常
        if: always()
        run: |
          echo "=== 🔧 确保网络正常 ==="
          echo "检查时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo ""
          
          echo "1️⃣ 停止任何Warp连接..."
          sudo wg-quick down wgcf 2>/dev/null || echo "   ℹ️ WARP未运行"
          sudo ip link delete wgcf 2>/dev/null || echo "   ℹ️ 接口不存在"
          
          echo "2️⃣ 清除Warp相关路由..."
          for cidr in "140.82.112.0/20" "185.199.108.0/22" "185.199.109.0/22" "185.199.110.0/22" "185.199.111.0/22"; do
            sudo ip route del $cidr 2>/dev/null || true
          done
          
          echo "3️⃣ 测试网络连接..."
          echo "   测试IP查询服务..."
          
          CURRENT_IP=""
          for server in "https://ip.sb" "https://api.ipify.org" "https://checkip.amazonaws.com" "https://ipinfo.io/ip"; do
            if CURRENT_IP=$(curl -4 -s --max-time 5 "$server" | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'); then
              echo "   ✅ 成功: $CURRENT_IP (来自 $server)"
              break
            fi
          done
          
          if [ -z "$CURRENT_IP" ]; then
            CURRENT_IP=$(hostname -I | awk '{print $1}' 2>/dev/null || echo "unknown")
            echo "   ℹ️ 备用IP: $CURRENT_IP"
          fi
          
          echo "4️⃣ 检查GitHub连接..."
          if curl -I --silent --max-time 10 https://github.com 2>/dev/null | head -1; then
            echo "   ✅ GitHub连接正常"
          else
            echo "   ⚠️  GitHub连接可能有问题"
          fi
          
          echo ""
          echo "=== 🔧 网络检查完成 ==="
      
      # ==================== 步骤13：自动提交更改 ====================
      - name: 自动提交更改
        if: success()
        run: |
          echo "=== 📤 自动提交更改 ==="
          echo "提交时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo ""
          
          if [ ! -f "flclashyaml/Tg-node1.yaml" ]; then
            echo "⚠️ 配置文件不存在，跳过提交"
            exit 0
          fi
          
          if ! git diff --quiet flclashyaml/Tg-node1.yaml 2>/dev/null; then
            echo "📝 检测到文件变化，准备提交..."
            
            git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add flclashyaml/Tg-node1.yaml
            
            COMMIT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            NODE_COUNT=$(python3 -c 'import yaml; d=yaml.safe_load(open("flclashyaml/Tg-node1.yaml",encoding="utf-8")); print(len(d.get("proxies",[])))' 2>/dev/null || echo "?")
            COMMIT_MESSAGE="🚀 自动更新：Telegram节点配置 (${NODE_COUNT}节点) - ${COMMIT_TIME}"
            
            echo "提交信息: ${COMMIT_MESSAGE}"
            git commit -m "${COMMIT_MESSAGE}"
            echo ""
            echo "开始推送..."
            git push origin HEAD
            echo "✅ 提交完成"
          else
            echo "📝 文件无变化，跳过提交"
          fi
