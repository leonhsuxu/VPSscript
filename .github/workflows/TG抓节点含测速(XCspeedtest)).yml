name: TG频道和群抓取节点测速 XC-speedtest测速版
# ==================== 触发条件配置 ====================
on:
  # 定时执行配置
  schedule:
    # 每4小时执行一次，整点后的10分钟执行（例如：00:10, 04:10, 08:10...）
    - cron: '10 */4 * * *'
  
  # 支持手动触发工作流
  workflow_dispatch:
    inputs:
      # 网络配置模式选择
      warp_config:
        description: '选择网络配置模式'
        required: false
        default: 'default'
        type: choice
        options:
          - default        # 默认配置：抓取用GitHub，测速用Warp
          - all_warp       # 全流程使用Warp网络
          - all_github     # 全流程使用GitHub网络
          - test_mode      # 测试模式（只抓取少量节点）
      
      # 是否强制重新下载工具
      force_download:
        description: '强制重新下载工具（忽略缓存）'
        required: false
        default: false
        type: boolean
      
      # 测速模式选择
      speedtest_mode:
        description: '选择测速模式'
        required: false
        default: 'tcp_first'
        type: choice
        options:
          - tcp_first     # 先TCP粗筛，再Speedtest精测（推荐）
          - tcp_only      # 只用TCP测速（最快）
          - clash_only    # 只用Speedtest测速（最准）
          - clash_first   # 先Speedtest，再TCP验证
# ==================== 环境变量配置 ====================
env:
  # ==================== 版本配置 ====================
  MIHOMO_VERSION: v1.19.17           # Mihomo (Clash Meta) 版本
  SPEEDTEST_VERSION: v0.4.1          # XC Speedtest 版本
  WGCF_VERSION: v2.2.29              # WGCF (Cloudflare Warp) 版本
  
  # ==================== 网络控制配置 ====================
  # 这些变量是Python脚本的唯一控制源，控制各阶段是否使用Warp网络
  # true=使用Warp网络，false=使用原始GitHub网络
  
  # 抓取阶段：使用GitHub网络（速度快）
  WARP_FOR_SCRAPING: "false"
  
  # TCP测速阶段：使用Warp网络（模拟国内环境，测速结果更准确）
  WARP_FOR_TCP: "true"
  
  # Speedtest测速阶段：使用Warp网络（模拟国内环境，测速结果更准确）
  WARP_FOR_SPEEDTEST: "true"
  
  # 最终处理阶段：使用GitHub网络（确保提交等操作正常）
  WARP_FOR_FINAL: "false"
  
  # ==================== 测速策略配置 ====================
  # 测速模式选项：
  #   "tcp_only"      → 只用 TCP 测速（最快，最严格，适合节点特别多的情况）
  #   "clash_only"    → 只用 Speedtest-clash 测速（最准）
  #   "tcp_first"     → 先 TCP 粗筛（<800ms）→ 再 Speedtest 精测（推荐！平衡速度与质量）
  #   "clash_first"   → 先 Speedtest → 再 TCP（一般用不上）
  SPEEDTEST_MODE: "tcp_first"
  
  # ==================== 带宽筛选配置 ====================
  # 是否启用带宽筛选（True=启用，False=关闭）
  ENABLE_BANDWIDTH_FILTER: "true"
  
  # 最低带宽阈值（单位：MB/s）
  # 只保留带宽大于等于此值的节点
  MIN_BANDWIDTH_MB: "25"
  
  # ==================== 日志配置 ====================
  # 是否启用TCP测速详细日志（生产环境建议关闭）
  ENABLE_TCP_LOG: "false"
  
  # 是否启用Speedtest测速详细日志（生产环境建议关闭）
  ENABLE_SPEEDTEST_LOG: "false"
  
  # ==================== Telegram频道配置 ====================
  # 要抓取的Telegram频道列表（每行一个）
  # 支持频道ID（如 @channel_name）或频道链接
  TELEGRAM_CHANNEL_IDS: |
    @fqDINYUE
    @wxdy666
    @freeyule
    @ccbaohe
    @duangvpsfs         
    @zzzjjjkkkoi
    @xmdexw
    @v2v2clash
    @dingyue_Center
    @tempssrlink
    @sorenab2
    @proxyshareCN
# ==================== 工作流任务定义 ====================
jobs:
  # 主构建任务
  build:
    # 使用最新的Ubuntu运行器
    runs-on: ubuntu-latest
    
    # 设置任务超时时间（单位：分钟）
    timeout-minutes: 30
    
    # 任务步骤定义
    steps:
      # ==================== 步骤1：检出代码仓库 ====================
      - name: 检出代码仓库
        uses: actions/checkout@v4
        with:
          # 获取完整的历史记录，便于后续的提交操作
          fetch-depth: 0
          # 使用GitHub Token进行认证
          token: ${{ secrets.GITHUB_TOKEN }}
          # 是否检出子模块
          submodules: false
      
      # ==================== 步骤2：设置Python环境 ====================
      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          # 指定Python版本（3.11）
          python-version: '3.11'
          # 启用缓存以加速依赖安装
          cache: 'pip'
          # 缓存依赖文件路径
          cache-dependency-path: '**/requirements.txt'
      
      # ==================== 步骤3：缓存Python依赖 ====================
      - name: 缓存 Python 依赖
        uses: actions/cache@v4
        id: cache-pip
        with:
          # 缓存pip安装包的位置
          path: ~/.cache/pip
          # 缓存的唯一标识键，基于requirements.txt的哈希值
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          # 如果没有完全匹配的缓存，尝试恢复最接近的缓存
          restore-keys: |
            ${{ runner.os }}-pip-
      
      # ==================== 步骤4：安装Python依赖及系统依赖 ====================
      - name: 安装 Python 依赖及系统依赖
        run: |
          # 升级pip到最新版本
          python -m pip install --upgrade pip
          
          # 安装requirements.txt中指定的Python包
          pip install -r requirements.txt
          
          # 更新系统包列表（静默模式）
          sudo apt-get update -qq
          
          # 安装必要的系统工具
          sudo apt-get install -y \
            wireguard-tools \
            curl \
            resolvconf \
            wget
      
      # ==================== 步骤5：缓存Mihomo程序 ====================
      - name: 缓存 Mihomo 程序
        id: cache-mihomo
        uses: actions/cache@v4
        with:
          # 缓存Mihomo二进制文件
          path: mihomo
          # 缓存键：基于架构和版本
          key: mihomo-amd64-${{ env.MIHOMO_VERSION }}
          # 恢复键：相同架构的不同版本
          restore-keys: mihomo-amd64-${{ env.MIHOMO_VERSION }}
      
      # ==================== 步骤6：下载Mihomo指定版本 ====================
      - name: 下载 Mihomo 指定版本
        if: steps.cache-mihomo.outputs.cache-hit != 'true' || inputs.force_download == true
        run: |
          set -e
          TAG=${{ env.MIHOMO_VERSION }}
          URL="https://github.com/MetaCubeX/mihomo/releases/download/${TAG}/mihomo-linux-amd64-${TAG}.gz"
          
          echo "尝试访问下载链接: $URL"
          if ! curl --head --fail "$URL"; then
            echo "❌ 错误：下载地址不可用！"
            exit 1
          fi
          
          wget --tries=3 --timeout=30 -O mihomo.gz "$URL"
          gunzip -f mihomo.gz
          chmod +x mihomo
          ./mihomo -v
      
      # ==================== 步骤7：缓存wgcf工具 ====================
      - name: 缓存 wgcf 工具
        id: cache-wgcf
        uses: actions/cache@v4
        with:
          # 缓存wgcf二进制文件
          path: wgcf
          # 缓存键：基于架构和版本
          key: wgcf-linux-amd64-${{ env.WGCF_VERSION }}
          # 恢复键
          restore-keys: wgcf-linux-amd64-${{ env.WGCF_VERSION }}
      
      # ==================== 步骤8：下载wgcf工具 ====================
      - name: 下载 wgcf 工具
        if: steps.cache-wgcf.outputs.cache-hit != 'true' || inputs.force_download == true
        run: |
          WGCF_FULL_VERSION="${{ env.WGCF_VERSION }}"
          WGCF_FILENAME_VERSION="${WGCF_FULL_VERSION#v}" 
          echo "正在下载 wgcf v${WGCF_FILENAME_VERSION}..."
          
          curl -fsSL -o wgcf "https://github.com/ViRb3/wgcf/releases/download/${WGCF_FULL_VERSION}/wgcf_${WGCF_FILENAME_VERSION}_linux_amd64"
          
          if [ ! -f "wgcf" ]; then
            echo "❌ 错误：wgcf 下载失败！"
            exit 1
          fi
          
          chmod +x wgcf
          echo "wgcf 下载完成。"
      
      # ==================== 步骤9：缓存speedtest-clash程序 ====================
      - name: 缓存 xiecang speedtest-clash
        id: cache-xc
        uses: actions/cache@v4
        with:
          # 缓存speedtest-clash二进制文件
          path: xcspeedtest
          # 缓存键：基于版本
          key: xiecang-${{ env.SPEEDTEST_VERSION }}
          # 恢复键
          restore-keys: xiecang-${{ env.SPEEDTEST_VERSION }}
      
      # ==================== 步骤10：下载speedtest-clash指定版本 ====================
      - name: 下载 xiecang speedtest-clash
        if: steps.cache-xc.outputs.cache-hit != 'true' || inputs.force_download == true
        run: |
          set -e
          RELEASE_TAG=${{ env.SPEEDTEST_VERSION }}
          echo "尝试下载 speedtest-clash 版本: $RELEASE_TAG"
          
          URL=$(curl -s "https://api.github.com/repos/xiecang/speedtest-clash/releases/tags/${RELEASE_TAG}" \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          
          if [ -z "$URL" ]; then
            echo "⚠️ 警告: 未找到指定版本 (${RELEASE_TAG})，尝试使用最新版本。"
            URL=$(curl -s https://api.github.com/repos/xiecang/speedtest-clash/releases/latest \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          fi
          
          if [ -z "$URL" ]; then
            echo "❌ 错误：未能找到 speedtest-clash 下载 URL，退出。"
            exit 1
          fi
          
          wget --tries=5 --timeout=60 -O downloaded_file "$URL"
          
          if file downloaded_file | grep -q "gzip compressed data"; then
            echo "检测到压缩包，开始解压"
            tar -xzf downloaded_file
            if [ -f "speedtest-clash" ]; then
              mv speedtest-clash xcspeedtest
            else
              EXE_PATH=$(find . -maxdepth 1 -type f -executable -name "speedtest-clash*" -print -quit)
              if [ -n "$EXE_PATH" ]; then
                mv "$EXE_PATH" xcspeedtest
              else
                echo "❌ 错误：未找到 speedtest-clash 可执行文件"
                exit 1
              fi
            fi
            rm downloaded_file
          else
            echo "下载的是可执行文件，直接重命名为 xcspeedtest"
            mv downloaded_file xcspeedtest
          fi
          
          chmod +x xcspeedtest
          ./xcspeedtest --help
      
      # ==================== 步骤11：智能网络配置 ====================
      - name: 智能网络配置
        run: |
          echo "=== 🌐 智能网络配置 ==="
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "手动触发工作流，网络配置模式: ${{ inputs.warp_config }}"
            
            case "${{ inputs.warp_config }}" in
              "default")
                echo "使用默认网络配置"
                ;;
              "all_warp")
                echo "全流程使用Warp网络"
                echo "WARP_FOR_SCRAPING=true" >> $GITHUB_ENV
                echo "WARP_FOR_TCP=true" >> $GITHUB_ENV
                echo "WARP_FOR_SPEEDTEST=true" >> $GITHUB_ENV
                echo "WARP_FOR_FINAL=true" >> $GITHUB_ENV
                ;;
              "all_github")
                echo "全流程使用GitHub网络"
                echo "WARP_FOR_SCRAPING=false" >> $GITHUB_ENV
                echo "WARP_FOR_TCP=false" >> $GITHUB_ENV
                echo "WARP_FOR_SPEEDTEST=false" >> $GITHUB_ENV
                echo "WARP_FOR_FINAL=false" >> $GITHUB_ENV
                ;;
              "test_mode")
                echo "测试模式：减少抓取数量，使用Warp测速"
                echo -e "TELEGRAM_CHANNEL_IDS=@fqDINYUE\n@wxdy666\n@freeyule" >> $GITHUB_ENV
                echo "WARP_FOR_SCRAPING=false" >> $GITHUB_ENV
                echo "WARP_FOR_TCP=true" >> $GITHUB_ENV
                echo "WARP_FOR_SPEEDTEST=true" >> $GITHUB_ENV
                echo "WARP_FOR_FINAL=false" >> $GITHUB_ENV
                ;;
            esac
            
            if [ -n "${{ inputs.speedtest_mode }}" ]; then
              echo "SPEEDTEST_MODE=${{ inputs.speedtest_mode }}" >> $GITHUB_ENV
              echo "测速模式覆盖为: ${{ inputs.speedtest_mode }}"
            fi
          else
            echo "定时触发，使用默认网络配置"
          fi
          
          echo ""
          echo "📋 最终执行配置:"
          echo "--------------------------------------------------"
          echo "网络配置:"
          echo "  - 抓取阶段 Warp: ${{ env.WARP_FOR_SCRAPING }}"
          echo "  - TCP测速 Warp: ${{ env.WARP_FOR_TCP }}"
          echo "  - Speedtest测速 Warp: ${{ env.WARP_FOR_SPEEDTEST }}"
          echo "  - 最终阶段 Warp: ${{ env.WARP_FOR_FINAL }}"
          echo ""
          echo "测速配置:"
          echo "  - 测速模式: ${{ env.SPEEDTEST_MODE }}"
          echo "  - 带宽筛选: ${{ env.ENABLE_BANDWIDTH_FILTER }} (≥${{ env.MIN_BANDWIDTH_MB }}MB/s)"
          echo "  - TCP日志: ${{ env.ENABLE_TCP_LOG }}"
          echo "  - Speedtest日志: ${{ env.ENABLE_SPEEDTEST_LOG }}"
          echo "--------------------------------------------------"
          echo "=== ✅ 网络配置完成 ==="
      
      # ==================== 步骤12：运行Telegram抓取及测速脚本 ====================
      - name: 运行 Telegram 抓取及 Clash 测速脚本
        env:
          # Telegram API 凭证
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_STRING_SESSION: ${{ secrets.TELEGRAM_STRING_SESSION }}
          
          # 网络控制变量
          WARP_FOR_SCRAPING: ${{ env.WARP_FOR_SCRAPING }}
          WARP_FOR_TCP: ${{ env.WARP_FOR_TCP }}
          WARP_FOR_SPEEDTEST: ${{ env.WARP_FOR_SPEEDTEST }}
          WARP_FOR_FINAL: ${{ env.WARP_FOR_FINAL }}
          
          # 测速配置
          SPEEDTEST_MODE: ${{ env.SPEEDTEST_MODE }}
          ENABLE_TCP_LOG: ${{ env.ENABLE_TCP_LOG }}
          ENABLE_SPEEDTEST_LOG: ${{ env.ENABLE_SPEEDTEST_LOG }}
          
          # 带宽筛选配置
          ENABLE_BANDWIDTH_FILTER: ${{ env.ENABLE_BANDWIDTH_FILTER }}
          MIN_BANDWIDTH_MB: ${{ env.MIN_BANDWIDTH_MB }}
          
          # 其他环境变量
          TELEGRAM_CHANNEL_IDS: ${{ env.TELEGRAM_CHANNEL_IDS }}
          GITHUB_ACTIONS: "true"
          PYTHONUNBUFFERED: "1"
          
        run: |
          mkdir -p flclashyaml
          
          echo "=== 🚀 开始执行节点抓取和测速 ==="
          echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo ""
          
          echo "📊 执行参数汇总:"
          echo "--------------------------------------------------"
          echo "网络配置:"
          echo "  📡 抓取阶段: $( [ "$WARP_FOR_SCRAPING" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo "  🚀 TCP测速: $( [ "$WARP_FOR_TCP" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo "  ⚡ Speedtest: $( [ "$WARP_FOR_SPEEDTEST" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo "  📝 最终处理: $( [ "$WARP_FOR_FINAL" = "true" ] && echo "使用Warp" || echo "使用GitHub" )"
          echo ""
          echo "测速配置:"
          echo "  🎯 测速模式: $SPEEDTEST_MODE"
          echo "  📶 带宽筛选: $( [ "$ENABLE_BANDWIDTH_FILTER" = "true" ] && echo "启用 (≥${MIN_BANDWIDTH_MB}MB/s)" || echo "关闭" )"
          echo "  📋 日志级别: TCP=$ENABLE_TCP_LOG, Speedtest=$ENABLE_SPEEDTEST_LOG"
          echo "--------------------------------------------------"
          echo ""
          
          echo "▶️ 开始执行Python脚本..."
          echo "--------------------------------------------------"
          
          python TelegramNode/TBD-telegram_publiclink.py
          
          EXIT_CODE=$?
          echo ""
          echo "--------------------------------------------------"
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "✅ 节点抓取和测速完成"
            
            if [ -f "flclashyaml/Tg-node1.yaml" ]; then
              FILE_SIZE=$(stat -c%s "flclashyaml/Tg-node1.yaml" 2>/dev/null || stat -f%z "flclashyaml/Tg-node1.yaml" 2>/dev/null || echo "unknown")
              echo "📁 配置文件生成成功: flclashyaml/Tg-node1.yaml (${FILE_SIZE} bytes)"
              
              echo "📄 配置文件预览:"
              head -20 flclashyaml/Tg-node1.yaml
            else
              echo "⚠️  配置文件未生成"
            fi
          else
            echo "❌ Python脚本执行失败，退出码: $EXIT_CODE"
            exit $EXIT_CODE
          fi
          
          echo ""
          echo "结束时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo "=== ✅ 脚本执行完成 ==="
      
      # ==================== 步骤13：提交前清理Warp连接 ====================
      - name: 提交前清理 Warp 连接
        if: always()
        run: |
          echo "=== 🧹 提交前清理 WARP 连接 ==="
          echo "清理时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo ""
          
          echo "1️⃣ 检查当前网络状态:"
          CURRENT_IP=$(curl -4 -s --max-time 5 https://ip.sb 2>/dev/null || echo "无法获取")
          echo "   当前出口 IP: $CURRENT_IP"
          
          echo "2️⃣ 停止 WARP VPN..."
          sudo wg-quick down wgcf 2>/dev/null || echo "   WARP未运行或停止失败"
          
          echo "3️⃣ 清理网络接口..."
          sudo ip link delete wgcf 2>/dev/null || echo "   接口不存在或删除失败"
          
          echo "4️⃣ 清理智能路由配置..."
          github_ranges=(
            "140.82.112.0/20"
            "185.199.108.0/22"
            "185.199.109.0/22"
            "185.199.110.0/22"
            "185.199.111.0/22"
          )
          
          cleaned_count=0
          for cidr in "${github_ranges[@]}"; do
            sudo ip route del $cidr 2>/dev/null && cleaned_count=$((cleaned_count + 1)) || true
          done
          echo "   已清理 $cleaned_count 个GitHub路由"
          
          echo "5️⃣ 刷新DNS缓存..."
          sudo systemctl restart systemd-resolved 2>/dev/null || echo "   DNS刷新失败"
          
          echo "6️⃣ 测试GitHub连接..."
          echo "   DNS解析测试:"
          timeout 5 nslookup github.com 2>&1 | head -3 || echo "   DNS解析失败"
          
          echo "   HTTP连接测试:"
          timeout 5 curl -I --silent https://github.com 2>&1 | head -2 || echo "   HTTP连接失败"
          
          echo "7️⃣ 等待网络稳定..."
          sleep 3
          
          echo "8️⃣ 验证清理结果:"
          FINAL_IP=$(curl -4 -s --max-time 5 https://ip.sb 2>/dev/null || echo "无法获取")
          echo "   最终出口 IP: $FINAL_IP"
          
          if echo "$FINAL_IP" | grep -q "162.159\|172.64"; then
            echo "   ⚠️  检测到可能仍是Warp IP，但已尽力清理"
          else
            echo "   ✅ 清理完成，已恢复原始网络"
          fi
          
          echo ""
          echo "=== ✅ 网络清理完成 ==="
      
      # ==================== 步骤14：提交生成的Clash配置到仓库 ====================
      - name: 提交生成的 Clash 配置到仓库
  if: success()
  run: |
    echo "=== 📤 提交变更到GitHub ==="
    echo "提交时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
    echo ""

    echo "🔍 检查文件变更..."
    if git status --porcelain | grep -q "flclashyaml/Tg-node1.yaml"; then
      echo "✅ 检测到配置文件变更"

      echo "👤 配置Git用户..."
      git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
      git config --local user.name "github-actions[bot]"

      echo "📝 添加变更文件..."
      git add flclashyaml/Tg-node1.yaml

      echo "📋 生成提交信息..."

      # python脚本单行版本，避免引号冲突
      COMMIT_TIME=$(python3 -c 'from datetime import datetime, timedelta; print((datetime.utcnow() + timedelta(hours=8)).strftime("%Y-%m-%d %H:%M:%S CST"))')

      NODE_INFO=$(python3 -c 'import yaml, sys; try: with open("flclashyaml/Tg-node1.yaml","r",encoding="utf-8") as f: data = yaml.safe_load(f); proxies=data.get("proxies",[]); node_count = len(proxies) if isinstance(proxies,list) else 0; avg_quality = data.get("average_quality","N/A"); quality_stats=data.get("quality_stats",{}); warp_tcp=data.get("speedtest_config",{}).get("warp_for_tcp","N/A"); warp_speedtest=data.get("speedtest_config",{}).get("warp_for_speedtest","N/A"); quality_str=""; \
if isinstance(quality_stats,dict): parts=[f"{k}{v}" for k,v in quality_stats.items()]; quality_str = "[" + " ".join(parts) + "]" if parts else ""; print(f"{node_count} nodes | {avg_quality}分 {quality_str} | TCP_Warp={warp_tcp} Speedtest_Warp={warp_speedtest}"); \
except Exception as e: print(f"读取失败: {str(e)[:50]}"); print("unknown nodes")')

      COMMIT_MESSAGE="🤖 自动更新节点配置 ${COMMIT_TIME} (${NODE_INFO})"

      echo "提交信息: $COMMIT_MESSAGE"

      echo "💾 提交更改..."
      git commit -m "$COMMIT_MESSAGE"

      echo "🔄 尝试推送变更到 GitHub..."
      MAX_RETRIES=3
      RETRY_COUNT=0
      PUSH_SUCCESS=false

      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        echo "推送尝试 $((RETRY_COUNT + 1))/$MAX_RETRIES"

        if git push; then
          echo "✅ 提交成功！"
          PUSH_SUCCESS=true
          break
        else
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "⚠️ 推送失败，尝试 $RETRY_COUNT/$MAX_RETRIES..."

          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "等待 5 秒后重试..."
            sleep 5

            echo "拉取最新代码..."
            git pull --rebase origin main || git pull --rebase origin master
          else
            echo "❌ 推送失败已达最大重试次数"
          fi
        fi
      done

      if [ "$PUSH_SUCCESS" = false ]; then
        echo "⚠️ 提交失败，但工作流将继续执行"
      fi

    else
      echo "📭 文件无变化，跳过提交"
    fi
      
      # ==================== 步骤15：最终清理和报告 ====================
      - name: 最终清理和报告
        if: always()
        run: |
          echo "=== 🧹 最终清理 ==="
          echo "清理时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo ""
          
          echo "1️⃣ 确保Warp完全停止..."
          sudo wg-quick down wgcf 2>/dev/null || true
          sudo ip link delete wgcf 2>/dev/null || true
          
          echo "2️⃣ 清理临时文件..."
          rm -f wgcf wgcf-profile.conf mihomo.gz downloaded_file 2>/dev/null || true
          
          echo "3️⃣ 工作流执行总结:"
          echo "   📅 执行时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          echo "   🖥️  运行器: $RUNNER_OS"
          
          if [ -f "flclashyaml/Tg-node1.yaml" ]; then
            FILE_SIZE=$(stat -c%s "flclashyaml/Tg-node1.yaml" 2>/dev/null || stat -f%z "flclashyaml/Tg-node1.yaml" 2>/dev/null || echo "unknown")
            echo "   📁 配置文件: flclashyaml/Tg-node1.yaml (${FILE_SIZE} bytes)"
            
            if command -v python3 &> /dev/null; then
              NODE_COUNT=$(python3 -c 'try: import yaml; f=open("flclashyaml/Tg-node1.yaml","r",encoding="utf-8"); data=yaml.safe_load(f); f.close(); proxies=data.get("proxies",[]); print(len(proxies) if isinstance(proxies,list) else "格式错误"); except: print("读取失败")')
              echo "   🔗 节点数量: ${NODE_COUNT}"
            fi
          else
            echo "   ❌ 配置文件未生成"
          fi
          
          echo "5️⃣ 最终网络状态:"
          echo "   IP地址:"
          curl -4 -s --max-time 3 https://ip.sb 2>/dev/null || echo "   获取失败"
          
          echo ""
          echo "=== ✅ 清理完成 ==="
