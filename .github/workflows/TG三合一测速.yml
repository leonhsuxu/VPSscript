# -*- coding: utf-8 -*-
"""
æ–‡ä»¶å: Telegram.Node_Final V1.R1 
è„šæœ¬è¯´æ˜:ä½¿ç”¨XC speedtestæµ‹é€Ÿ
æœ¬è„šæœ¬å®ç°ä»æŒ‡å®š Telegram é¢‘é“è‡ªåŠ¨çˆ¬å–è®¢é˜…é“¾æ¥ï¼›
ä¸‹è½½å¹¶è§£æå„ç§ä»£ç†è®¢é˜…èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ vmess, vless, ssr, ss, trojan, hysteriaåŠhysteria2ç­‰åè®®ï¼‰ï¼Œ
æ”¯æŒèŠ‚ç‚¹å»é‡ã€åœ°åŒºè¯†åˆ«ä¸é‡å‘½åï¼Œå¹¶ä½¿ç”¨ Clash æ ¸å¿ƒç¨‹åºè¿›è¡ŒèŠ‚ç‚¹æµ‹é€Ÿï¼ˆå»¶è¿Ÿæµ‹è¯•ï¼‰ï¼›
æœ€ç»ˆç”Ÿæˆå¯ç”¨äº Clash ä½¿ç”¨çš„ YAML é…ç½®æ–‡ä»¶ã€‚
ä¸»è¦åŠŸèƒ½:
1. ä» Telegram æŒ‡å®šé¢‘é“æŠ“å–å¸¦æœ‰è®¢é˜…é“¾æ¥çš„æ¶ˆæ¯ï¼Œæ”¯æŒæ—¶é—´çª—å£è¿‡æ»¤æ–°æ¶ˆæ¯ã€‚
2. æ”¯æŒå¤šç§å¸¸è§ä»£ç†åè®®çš„èŠ‚ç‚¹è§£æï¼Œä»¥åŠè¯†åˆ«èŠ‚ç‚¹æ‰€åœ¨åŒºåŸŸã€‚
3. é‡‡ç”¨å‘½ä»¤è¡Œæ¨¡å¼è°ƒç”¨ clash æ ¸å¿ƒç¨‹åºè¿›è¡ŒèŠ‚ç‚¹å»¶è¿Ÿæµ‹è¯•ï¼Œç­›é€‰æœ‰æ•ˆèŠ‚ç‚¹ã€‚
4. æ ¹æ®èŠ‚ç‚¹åœ°åŒºä¸å»¶è¿Ÿè‡ªåŠ¨æ’åºå’Œå½’ç±»ï¼Œç”Ÿæˆæœ€ç»ˆé…ç½®æ–‡ä»¶ã€‚
5. ç¯å¢ƒå˜é‡é…ç½®çµæ´»ï¼Œæ–¹ä¾¿é›†æˆè‡ªåŠ¨åŒ–æµç¨‹ã€‚
"""
import os
import re
import sys
import base64
import json
import yaml
import time
import socket
import hashlib
import asyncio
import shutil
import subprocess
import concurrent.futures
import tempfile
import requests
import socket
# === æ–°å¢è¿™å‡ è¡Œï¼Œè­¦å‘Šç«‹åˆ»æ¶ˆå¤± ===
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="urllib3.connectionpool")
# ============================================
from concurrent.futures import as_completed
from urllib.parse import urlparse, parse_qs, unquote
from datetime import datetime, timedelta, timezone
from collections import defaultdict
from telethon.sync import TelegramClient
from telethon.sessions import StringSession

# --- ç¯å¢ƒå˜é‡è¯»å– ---
API_ID = int(os.environ.get('TELEGRAM_API_ID') or 0)
API_HASH = os.environ.get('TELEGRAM_API_HASH')
STRING_SESSION = os.environ.get('TELEGRAM_STRING_SESSION')
TELEGRAM_CHANNEL_IDS_STR = os.environ.get('TELEGRAM_CHANNEL_IDS', '')
TIME_WINDOW_HOURS = 4  # æŠ“å–å¤šé•¿æ—¶é—´çš„æ¶ˆæ¯ï¼Œå•ä½ä¸ºå°æ—¶ã€‚
MIN_EXPIRE_HOURS = 2   # è®¢é˜…åœ°å€å‰©ä½™æ—¶é—´æœ€å°è¿‡æœŸï¼Œå•ä½ä¸ºå°æ—¶ã€‚
OUTPUT_FILE = 'flclashyaml/Tg-node1.yaml'  # è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼Œç”¨äºä¿å­˜ç”Ÿæˆçš„é…ç½®æˆ–ç»“æœã€‚
last_warp_start_time = 0

# === æ–°å¢ï¼šæµ‹é€Ÿç­–ç•¥å¼€å…³ï¼ˆæ¨èä¿ç•™è¿™å‡ ä¸ªé€‰é¡¹ï¼‰===
# æµ‹é€Ÿæ¨¡å¼ï¼š
# âš ï¸ æ³¨æ„: DETAILED_SPEEDTEST_MODE å°†é€šè¿‡ GitHub Actions çš„ inputs.speedtest_mode æˆ– env ä¼ å…¥
DETAILED_SPEEDTEST_MODE = os.getenv('DETAILED_SPEEDTEST_MODE', '').strip().lower()

# TCP å’ŒClash æµ‹é€Ÿä¸“å±å‚æ•°
TCP_TIMEOUT = 3.5          # å•æ¬¡ TCP è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå»ºè®® 3~5
TCP_MAX_WORKERS = 256     # TCP æµ‹é€Ÿæœ€å¤§å¹¶å‘ï¼ˆå¯ä»¥æ¯” Clash é«˜å¾ˆå¤šï¼Œéå¸¸å¿«ï¼‰
TCP_MAX_DELAY = 1000       # TCP å»¶è¿Ÿé˜ˆå€¼ï¼Œè¶…è¿‡æ­¤å€¼ç›´æ¥ä¸¢å¼ƒï¼ˆmsï¼‰

# TCP å’ŒClash æ—¥å¿—ç¯å¢ƒå˜é‡ä¸“å±å‚æ•°
def str_to_bool(s: str) -> bool:
    return s.strip().lower() in ('true', '1', 'yes')
    
ENABLE_TCP_LOG = str_to_bool(os.getenv('ENABLE_TCP_LOG', 'false'))
ENABLE_SPEEDTEST_LOG = str_to_bool(os.getenv('ENABLE_SPEEDTEST_LOG', 'false'))

MAX_TEST_WORKERS = 48    # é€Ÿåº¦æµ‹è¯•æ—¶æœ€å¤§å¹¶å‘å·¥ä½œçº¿ç¨‹æ•°ï¼Œæ§åˆ¶æµ‹è¯•çš„å¹¶è¡Œåº¦ã€‚å»ºè®®64-96
SOCKET_TIMEOUT = 3       # å¥—æ¥å­—è¿æ¥è¶…æ—¶æ—¶é—´ï¼Œå•ä½ä¸ºç§’
HTTP_TIMEOUT = 5         # HTTPè¯·æ±‚è¶…æ—¶æ—¶é—´ï¼Œå•ä½ä¸ºç§’

# ã€å…³é”®ä¿®æ”¹1ã€‘æµ‹é€Ÿç›®æ ‡å…¨éƒ¨æ¢æˆå›½å†…/Cloudflareä¸­å›½èŠ‚ç‚¹
TEST_URLS_GITHUB = [
    "https://www.google.com/generate_204",
    "https://clients3.google.com/generate_204"
]
TEST_URLS_WARP = [
    'http://www.baidu.com/generate_204',
    'http://qq.com/generate_204',
    'http://connect.rom.miui.com/generate_204',
    'http://connectivitycheck.platform.hicloud.com/generate_204'
]
# ==================== æµ‹é€Ÿç»“æœ_å¸¦å®½ç­›é€‰é…ç½®ï¼ˆæ–°å¢ï¼‰ ====================
# æ˜¯å¦å¯ç”¨å¸¦å®½ç­›é€‰ï¼ˆTrue=å¯ç”¨ï¼ŒFalse=å…³é—­ï¼‰
ENABLE_BANDWIDTH_FILTER = os.getenv('ENABLE_BANDWIDTH_FILTER', 'true').lower() == 'true'
# æœ€ä½å¸¦å®½é˜ˆå€¼ï¼ˆå•ä½ï¼šMB/sï¼‰
# æ”¯æŒç¯å¢ƒå˜é‡è®¾ç½®ï¼Œä¾‹å¦‚åœ¨ GitHub Actions é‡Œè¿™æ ·å†™ï¼š
# ENABLE_BANDWIDTH_FILTER=true
# MIN_BANDWIDTH_MB=30
MIN_BANDWIDTH_MB = float(os.getenv('MIN_BANDWIDTH_MB', '25'))  # ç­›é€‰æµ‹é€Ÿå®½åº¦çš„é€Ÿåº¦ã€‚é»˜è®¤ 25MB/sï¼Œå¯è‡ªç”±æ”¹
# ==================== å›½å®¶åŒ¹é…é…ç½® ====================
ALLOWED_REGIONS = {
    'é¦™æ¸¯', 'å°æ¹¾', 'æ—¥æœ¬', 'æ–°åŠ å¡', 'éŸ©å›½', 'é©¬æ¥è¥¿äºš', 'æ³°å›½',
    'å°åº¦', 'è²å¾‹å®¾', 'å°åº¦å°¼è¥¿äºš', 'è¶Šå—', 'ç¾å›½', 'åŠ æ‹¿å¤§',
    'æ³•å›½', 'è‹±å›½', 'å¾·å›½', 'ä¿„ç½—æ–¯', 'æ„å¤§åˆ©', 'å·´è¥¿',
    'é˜¿æ ¹å»·', 'åœŸè€³å…¶', 'æ¾³å¤§åˆ©äºš'
}
REGION_PRIORITY = [
    'é¦™æ¸¯', 'å°æ¹¾', 'æ—¥æœ¬', 'æ–°åŠ å¡', 'éŸ©å›½', 'é©¬æ¥è¥¿äºš', 'æ³°å›½',
    'å°åº¦', 'è²å¾‹å®¾', 'å°åº¦å°¼è¥¿äºš', 'è¶Šå—', 'ç¾å›½', 'åŠ æ‹¿å¤§',
    'æ³•å›½', 'è‹±å›½', 'å¾·å›½', 'ä¿„ç½—æ–¯', 'æ„å¤§åˆ©', 'å·´è¥¿',
    'é˜¿æ ¹å»·', 'åœŸè€³å…¶', 'æ¾³å¤§åˆ©äºš'
]
CUSTOM_REGEX_RULES = {
    'é¦™æ¸¯': {
        'code': 'HK',
        'pattern': r'é¦™æ¸¯|æ¸¯|HK|Hong\s*Kong|HongKong|HKBN|HGC|PCCW|WTT|HKT|ä¹é¾™|æ²™ç”°|å±¯é—¨|èƒæ¹¾|æ·±æ°´åŸ—|æ²¹å°–æ—º'
    },
    'æ—¥æœ¬': {
        'code': 'JP',
        'pattern': r'æ—¥æœ¬|æ—¥|å·æ—¥|ä¸œäº¬|å¤§é˜ª|æ³‰æ—¥|æ²ªæ—¥|æ·±æ—¥|äº¬æ—¥|å¹¿æ—¥|JP|Japan|Tokyo|Osaka|Saitama|åŸ¼ç‰|åå¤å±‹|Nagoya|ç¦å†ˆ|Fukuoka|æ¨ªæ»¨|Yokohama|NTT|IIJ|GMO|Linode'
    },
    'æ–°åŠ å¡': {
        'code': 'SG',
        'pattern': r'æ–°åŠ å¡|å¡|ç‹®åŸ|ç‹®|æ–°|SG|Singapore|SG\d+|SGP|æ˜Ÿ|ç‹®å­åŸ'
    },
    'ç¾å›½': {
        'code': 'US',
        'pattern': r'ç¾å›½|ç¾|æ³¢ç‰¹å…°|è¾¾æ‹‰æ–¯|Oregon|ä¿„å‹’å†ˆ|å‡¤å‡°åŸ|ç¡…è°·|æ‹‰æ–¯ç»´åŠ æ–¯|æ´›æ‰çŸ¶|åœ£ä½•å¡|è¥¿é›…å›¾|èŠåŠ å“¥|çº½çº¦|è¿ˆé˜¿å¯†|äºšç‰¹å…°å¤§|US|USA|United\s*States|America|LA|NYC|SF|San\s*Francisco|Washington|åç››é¡¿|Kansas|å ªè¨æ–¯|Denver|ä¸¹ä½›|Phoenix|Seattle|Chicago|Boston|æ³¢å£«é¡¿|Atlanta|Miami|Las\s*Vegas'
    },
    'å°æ¹¾': {
        'code': 'TW',
        'pattern': r'å°æ¹¾|æ¹¾çœ|å°|TW|Taiwan|TWN|å°åŒ—|Taipei|å°ä¸­|Taichung|é«˜é›„|Kaohsiung|æ–°åŒ—|å½°åŒ–|Hinet|ä¸­åç”µä¿¡'
    },
    'éŸ©å›½': {
        'code': 'KR',
        'pattern': r'éŸ©å›½|éŸ©|å—æœé²œ|é¦–å°”|é‡œå±±|ä»å·|KR|Korea|KOR|éŸ“|Seoul|Busan|KT|SK|LG'
    },
    'å¾·å›½': {
        'code': 'DE',
        'pattern': r'å¾·å›½|å¾·|æ³•å…°å…‹ç¦|æ…•å°¼é»‘|æŸæ—|DE|Germany|Frankfurt|Munich|Berlin|Hetzner'
    },
    'è‹±å›½': {
        'code': 'GB',
        'pattern': r'è‹±å›½|è‹±|ä¼¦æ•¦|æ›¼å½»æ–¯ç‰¹|UK|GB|United\s*Kingdom|Britain|England|London|Manchester'
    },
    'åŠ æ‹¿å¤§': {'code': 'CA', 'pattern': r'åŠ æ‹¿å¤§|æ«å¶|å¤šä¼¦å¤š|æ¸©å“¥å|è’™ç‰¹åˆ©å°”|CA|Canada'},
    'æ¾³å¤§åˆ©äºš': {'code': 'AU', 'pattern': r'æ¾³å¤§åˆ©äºš|æ¾³æ´²|æ‚‰å°¼|AU|Australia'},
    'è¶Šå—': {'code': 'VN', 'pattern': r'è¶Šå—|VN|Vietnam'},
    'å°åº¦': {'code': 'IN', 'pattern': r'å°åº¦|IN|India'},
    'é©¬æ¥è¥¿äºš': {'code': 'MY', 'pattern': r'é©¬æ¥è¥¿äºš|é©¬æ¥|MY|Malaysia'},
    'æ³•å›½': {'code': 'FR', 'pattern': r'æ³•å›½|FR|France'},
    'æ³°å›½': {
    'code': 'TH',
    'pattern': r'æ³°å›½|TH|Thailand|æ›¼è°·|Bangkok'
},
    'è²å¾‹å®¾': {
    'code': 'PH',
    'pattern': r'è²å¾‹å®¾|PH|Philippines|é©¬å°¼æ‹‰|Manila'
},
    'å°åº¦å°¼è¥¿äºš': {
    'code': 'ID',
    'pattern': r'å°åº¦å°¼è¥¿äºš|å°å°¼|ID|Indonesia|é›…åŠ è¾¾|Jakarta'
},
    'ä¿„ç½—æ–¯': {
    'code': 'RU',
    'pattern': r'ä¿„ç½—æ–¯|RU|Russia|è«æ–¯ç§‘|Moscow'
},
    'æ„å¤§åˆ©': {
    'code': 'IT',
    'pattern': r'æ„å¤§åˆ©|IT|Italy|ç½—é©¬|Rome'
},
    'å·´è¥¿': {
    'code': 'BR',
    'pattern': r'å·´è¥¿|BR|Brazil|åœ£ä¿ç½—|SÃ£o\s*Paulo'
},
    'é˜¿æ ¹å»·': {
    'code': 'AR',
    'pattern': r'é˜¿æ ¹å»·|AR|Argentina|å¸ƒå®œè¯ºæ–¯è‰¾åˆ©æ–¯|Buenos\s*Aires'
},
    'åœŸè€³å…¶': {
    'code': 'TR',
    'pattern': r'åœŸè€³å…¶|TR|Turkey|ä¼Šæ–¯å¦å¸ƒå°”|Istanbul'
}
}
FLAG_EMOJI_PATTERN = re.compile(r'[\U0001F1E6-\U0001F1FF]{2}')
BJ_TZ = timezone(timedelta(hours=8))

# ==================== æ ¹æ®ç½‘ç»œé€‰æ‹©æµ‹é€Ÿåœ°å€ï¼Œåœ°å€å¦‚ä¸Šå˜é‡ ====================
def get_test_urls():
    if is_warp_enabled():
        print("æ£€æµ‹åˆ° Warp ç½‘ç»œï¼Œä½¿ç”¨å›½å†…æµ‹é€Ÿåœ°å€")
        return TEST_URLS_WARP
    else:
        print("é Warp ç½‘ç»œï¼Œä½¿ç”¨è°·æ­Œæµ‹é€Ÿåœ°å€")
        return TEST_URLS_GITHUB
# ==================== æ™ºèƒ½ç½‘ç»œæ§åˆ¶é…ç½® ====================
def get_network_config():
    """
    è·å–ç½‘ç»œé…ç½®ï¼Œå¦‚æœç¯å¢ƒå˜é‡ä¸å­˜åœ¨åˆ™ä½¿ç”¨æ™ºèƒ½é»˜è®¤å€¼å¹¶è­¦å‘Š
    è¿”å›é…ç½®å­—å…¸å’Œæ˜¯å¦æ‰€æœ‰é…ç½®éƒ½æ¥è‡ªç¯å¢ƒå˜é‡
    """
    config = {}
    all_from_env = True
    
    # é…ç½®æ˜ å°„è¡¨ï¼šç¯å¢ƒå˜é‡å -> é»˜è®¤å€¼ -> æè¿°
    config_spec = {
        'WARP_FOR_SCRAPING': {
            'default': False, 
            'desc': 'TelegramæŠ“å–é˜¶æ®µä½¿ç”¨Warpç½‘ç»œ',
            'recommend': 'falseï¼ˆä½¿ç”¨GitHubç½‘ç»œï¼Œé€Ÿåº¦å¿«ï¼‰'
        },
        'WARP_FOR_TCP': {
            'default': True, 
            'desc': 'TCPæµ‹é€Ÿé˜¶æ®µä½¿ç”¨Warpç½‘ç»œ',
            'recommend': 'trueï¼ˆä½¿ç”¨Warpæ¨¡æ‹Ÿå›½å†…ç¯å¢ƒï¼‰'
        },
        'WARP_FOR_SPEEDTEST': {
            'default': True, 
            'desc': 'Speedtestæµ‹é€Ÿé˜¶æ®µä½¿ç”¨Warpç½‘ç»œ',
            'recommend': 'trueï¼ˆä½¿ç”¨Warpæ¨¡æ‹Ÿå›½å†…ç¯å¢ƒï¼‰'
        },
        'WARP_FOR_FINAL': {
            'default': False, 
            'desc': 'æœ€ç»ˆå¤„ç†é˜¶æ®µä½¿ç”¨Warpç½‘ç»œ',
            'recommend': 'falseï¼ˆåˆ‡æ¢å›GitHubç½‘ç»œï¼‰'
        },
    }
    
    print("ğŸ”§ ç½‘ç»œé…ç½®æ£€æŸ¥:")
    print("-" * 50)
    
    for env_name, spec in config_spec.items():
        env_value = os.getenv(env_name)
        if env_value is None:
            # ç¯å¢ƒå˜é‡ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤å€¼
            config[env_name] = spec['default']
            all_from_env = False
            print(f"âš ï¸  {env_name}: æœªè®¾ç½® â†’ ä½¿ç”¨é»˜è®¤å€¼: {spec['default']}")
            print(f"   æè¿°: {spec['desc']}")
            print(f"   å»ºè®®: {spec['recommend']}")
            print(f"   è®¾ç½®æ–¹æ³•: åœ¨GitHub Actions YMLä¸­æ·»åŠ : {env_name}: '{str(spec['default']).lower()}'")
        else:
            # ç¯å¢ƒå˜é‡å­˜åœ¨ï¼Œè½¬æ¢ä¸ºå¸ƒå°”å€¼
            config[env_name] = env_value.lower() == 'true'
            print(f"âœ…  {env_name}: å·²è®¾ç½® â†’ {env_value}")
    
    print("-" * 50)
    
    if not all_from_env:
        print("ğŸ“ æç¤º: éƒ¨åˆ†é…ç½®ä½¿ç”¨é»˜è®¤å€¼ï¼Œå»ºè®®åœ¨GitHub Actions YMLä¸­å®Œæ•´é…ç½®")
        print("       è¿™æ ·å¯ä»¥è·å¾—æ›´å¯æ§çš„ç½‘ç»œè¡Œä¸ºå’Œæ›´å¥½çš„æµ‹é€Ÿç»“æœ")
    else:
        print("ğŸ¯ æ‰€æœ‰ç½‘ç»œé…ç½®å‡æ¥è‡ªç¯å¢ƒå˜é‡ï¼Œé…ç½®å®Œæ•´ï¼")
    
    return config

# è·å–ç½‘ç»œé…ç½®
network_config = get_network_config()
WARP_FOR_SCRAPING = network_config['WARP_FOR_SCRAPING']
WARP_FOR_TCP = network_config['WARP_FOR_TCP']
WARP_FOR_SPEEDTEST = network_config['WARP_FOR_SPEEDTEST']
WARP_FOR_FINAL = network_config['WARP_FOR_FINAL']

# ==================== å®Œæ•´çš„ç½‘ç»œæ§åˆ¶å‡½æ•° ====================
def get_current_ip():
    """è·å–å½“å‰å‡ºå£IPï¼Œå¢å¼ºå®¹é”™æ€§"""
    try:
        # å°è¯•å¤šä¸ªIPæ£€æµ‹æœåŠ¡
        ip_services = [
            "https://api.ipify.org",
            "https://ipinfo.io/ip",
            "https://ifconfig.me/ip",
            "https://ip.sb",
            "https://checkip.amazonaws.com"
        ]
        
        for service in ip_services:
            try:
                result = subprocess.run(
                    ["curl", "-4", "-s", "--max-time", "5", service],
                    capture_output=True, text=True, timeout=6
                )
                if result.returncode == 0 and result.stdout.strip():
                    ip = result.stdout.strip()
                    # éªŒè¯IPæ ¼å¼
                    if re.match(r'^\d{1,3}(\.\d{1,3}){3}$', ip):
                        # åˆ¤æ–­æ˜¯å¦ä¸ºWarp IP
                        warp_prefixes = ['162.159.192.', '162.159.193.', '162.159.195.', 
                                       '172.64.240.', '172.64.241.', '172.64.242.', '172.64.243.']
                        for prefix in warp_prefixes:
                            if ip.startswith(prefix):
                                return f"{ip} (ğŸŒ Warpç½‘ç»œ)"
                        return f"{ip} (ğŸ’» åŸå§‹ç½‘ç»œ)"
            except:
                continue
        
        # å¦‚æœæ‰€æœ‰æœåŠ¡éƒ½å¤±è´¥ï¼Œå°è¯•ç›´æ¥æŸ¥è¯¢è·¯ç”±è¡¨
        try:
            result = subprocess.run(
                ["ip", "route", "get", "1"],
                capture_output=True, text=True, timeout=3
            )
            lines = result.stdout.split('\n')
            for line in lines:
                if 'src' in line:
                    parts = line.split()
                    for i, part in enumerate(parts):
                        if part == 'src':
                            ip = parts[i+1]
                            if re.match(r'^\d{1,3}(\.\d{1,3}){3}$', ip):
                                return f"{ip} (ğŸ“¡ æœ¬åœ°è·¯ç”±)"
        except:
            pass
        
        return "unknown (æ— æ³•è·å–)"
        
    except Exception as e:
        return f"unknown (å¼‚å¸¸: {str(e)[:30]})"
        
# == æ£€æŸ¥warp ==

def is_warp_enabled():
    """æ£€æŸ¥Warpæ˜¯å¦å¯ç”¨"""
    try:
        result = subprocess.run(
            ["wg", "show"],
            capture_output=True, text=True,
            timeout=3
        )
        # æ£€æŸ¥wgcfæ¥å£æ˜¯å¦å­˜åœ¨
        if result.returncode == 0 and "wgcf" in result.stdout:
            return True
        
        # é¢å¤–æ£€æŸ¥wg-quickçŠ¶æ€
        result2 = subprocess.run(
            ["ip", "link", "show", "wgcf"],
            capture_output=True, text=True,
            timeout=2
        )
        return result2.returncode == 0
        
    except (subprocess.TimeoutExpired, FileNotFoundError, Exception) as e:
        return False

# ==           
def start_cloudflare_warp():
    """
    åœ¨ GitHub Actions ä¸­å¯ç”¨ Cloudflare Warp
    æ¨¡æ‹Ÿå›½å†…ç½‘ç»œç¯å¢ƒï¼Œä½¿æµ‹é€Ÿç»“æœå¯¹å›½å†…ç”¨æˆ·æœ‰æ•ˆ
    """
    print("ğŸŒ æ­£åœ¨å¯åŠ¨ Cloudflare Warpï¼ˆæ¨¡æ‹Ÿå›½å†…ç½‘ç»œç¯å¢ƒï¼‰...")
    print("=" * 60)
    
    # å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»åœ¨WarpçŠ¶æ€
    current_warp = is_warp_enabled()
    if current_warp:
        current_ip = get_current_ip()
        print("âœ… Warpå·²å¯ç”¨ï¼Œå½“å‰çŠ¶æ€:")
        print(f"   IPåœ°å€: {current_ip}")
        print("   ğŸ“ æ— éœ€é‡æ–°å¯åŠ¨")
        return True
    
    # è®°å½•å¼€å§‹æ—¶é—´ï¼Œé¿å…çŸ­æ—¶é—´å†…é‡å¤å¯åŠ¨
    global last_warp_start_time
    current_time = time.time()
    
    # å¦‚æœä¸Šæ¬¡å¯åŠ¨åœ¨30ç§’å†…ï¼Œç›´æ¥è¿”å›
    if 'last_warp_start_time' in globals() and current_time - last_warp_start_time < 30:
        print("ğŸ•’ ä¸Šæ¬¡å¯åŠ¨ä¸åˆ°30ç§’ï¼Œè·³è¿‡é‡å¤å¯åŠ¨")
        return True
    
    last_warp_start_time = current_time
    
    try:
        # 1. æ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§é…ç½®ï¼ˆå®‰å…¨æ¸…ç†ï¼‰
        print("1ï¸âƒ£ æ¸…ç†æ—§é…ç½®...")
        # ä½¿ç”¨æ­£ç¡®çš„subprocessè°ƒç”¨æ–¹å¼
        try:
            subprocess.run(
                ["sudo", "wg-quick", "down", "wgcf"],
                capture_output=True,  # åªä½¿ç”¨capture_output
                timeout=10
            )
        except subprocess.TimeoutExpired:
            print("   â° æ¸…ç†è¶…æ—¶ï¼Œç»§ç»­æ‰§è¡Œ")
        
        # ç­‰å¾…æ¸…ç†å®Œæˆ
        time.sleep(1)
        
        # 2. æ£€æŸ¥å¹¶å®‰è£…å¿…è¦å·¥å…·
        print("2ï¸âƒ£ æ£€æŸ¥ç³»ç»Ÿä¾èµ–...")
        required_tools = ["wg-quick", "curl", "resolvconf"]
        missing_tools = []
        
        for tool in required_tools:
            if not shutil.which(tool):
                missing_tools.append(tool)
        
        if missing_tools:
            print(f"   å®‰è£…ç¼ºå¤±å·¥å…·: {', '.join(missing_tools)}")
            subprocess.run(
                ["sudo", "apt-get", "update", "-qq"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            subprocess.run(
                ["sudo", "apt-get", "install", "-y", "wireguard-tools", "curl", "resolvconf"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
        else:
            print("   âœ… æ‰€æœ‰å·¥å…·å·²å®‰è£…")
        
        # 3. ä¸‹è½½ wgcf å·¥å…·ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        wgcf_path = "./wgcf"
        if not os.path.exists(wgcf_path) or not os.access(wgcf_path, os.X_OK):
            print("3ï¸âƒ£ ä¸‹è½½ wgcf å·¥å…·...")
            try:
                # ä¿®æ­£ï¼šä½¿ç”¨æ­£ç¡®çš„curlå‚æ•°
                result = subprocess.run([
                    "curl", "-fsSL", "-o", wgcf_path,
                    "https://github.com/ViRb3/wgcf/releases/download/v2.2.29/wgcf_2.2.29_linux_amd64"
                ], timeout=30)
                
                if result.returncode == 0:
                    os.chmod(wgcf_path, 0o755)
                    print("   âœ… wgcf ä¸‹è½½æˆåŠŸ")
                else:
                    print(f"   âŒ wgcf ä¸‹è½½å¤±è´¥ï¼Œè¿”å›ç : {result.returncode}")
                    # å°è¯•å¤‡ç”¨ä¸‹è½½æº
                    print("   å°è¯•å¤‡ç”¨ä¸‹è½½æº...")
                    subprocess.run([
                        "wget", "-qO", wgcf_path,
                        "https://github.com/ViRb3/wgcf/releases/download/v2.2.29/wgcf_2.2.29_linux_amd64"
                    ], timeout=30)
                    if os.path.exists(wgcf_path):
                        os.chmod(wgcf_path, 0o755)
                        print("   âœ… wgcf å¤‡ç”¨ä¸‹è½½æˆåŠŸ")
                    else:
                        print("   âŒ wgcf ä¸‹è½½å…¨éƒ¨å¤±è´¥")
                        return False
                        
            except Exception as e:
                print(f"   âŒ wgcf ä¸‹è½½å¼‚å¸¸: {e}")
                return False
        else:
            print("   âœ… wgcf å·²å­˜åœ¨")
        
        # 4. ç”Ÿæˆé…ç½®æ–‡ä»¶
        config_file = "wgcf-profile.conf"
        if not os.path.exists(config_file):
            print("4ï¸âƒ£ ç”Ÿæˆ WARP é…ç½®æ–‡ä»¶...")
            try:
                # æ³¨å†ŒWarpè´¦æˆ·
                register_result = subprocess.run(
                    [wgcf_path, "register", "--accept-tos"],
                    stdout=subprocess.PIPE,  # åˆ†å¼€æŒ‡å®š
                    stderr=subprocess.PIPE,
                    text=True,
                    timeout=60
                )
                if register_result.returncode != 0:
                    print(f"   âš ï¸  æ³¨å†Œè­¦å‘Š: {register_result.stderr[:100]}")
                
                # ç”Ÿæˆé…ç½®æ–‡ä»¶
                generate_result = subprocess.run(
                    [wgcf_path, "generate"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    timeout=60
                )
                
                if generate_result.returncode == 0 and os.path.exists(config_file):
                    print("   âœ… é…ç½®æ–‡ä»¶ç”ŸæˆæˆåŠŸ")
                else:
                    print(f"   âŒ é…ç½®æ–‡ä»¶ç”Ÿæˆå¤±è´¥: {generate_result.stderr[:100]}")
                    # å°è¯•ä½¿ç”¨å¤‡ç”¨é…ç½®
                    print("   å°è¯•ä½¿ç”¨å¤‡ç”¨é…ç½®...")
                    create_backup_config(config_file)
                    
            except Exception as e:
                print(f"   âŒ é…ç½®ç”Ÿæˆå¼‚å¸¸: {e}")
                create_backup_config(config_file)
        else:
            print("   âœ… é…ç½®æ–‡ä»¶å·²å­˜åœ¨")
        
        # 5. å®‰è£…é…ç½®æ–‡ä»¶
        print("5ï¸âƒ£ å®‰è£… WARP é…ç½®...")
        try:
            subprocess.run(["sudo", "mkdir", "-p", "/etc/wireguard"], 
                         stdout=subprocess.DEVNULL,
                         stderr=subprocess.DEVNULL)
            subprocess.run(["sudo", "cp", config_file, "/etc/wireguard/wgcf.conf"], 
                         stdout=subprocess.DEVNULL,
                         stderr=subprocess.DEVNULL)
            print("   âœ… é…ç½®æ–‡ä»¶å®‰è£…æˆåŠŸ")
        except Exception as e:
            print(f"   âŒ é…ç½®æ–‡ä»¶å®‰è£…å¤±è´¥: {e}")
            return False
        
        # 6. å¯åŠ¨ WARP
        print("6ï¸âƒ£ å¯åŠ¨ WARP VPN...")
        try:
            start_result = subprocess.run(
                ["sudo", "wg-quick", "up", "wgcf"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=30
            )
            
            # æ£€æŸ¥å¯åŠ¨ç»“æœ
            if start_result.returncode == 0:
                print("   âœ… WARP å¯åŠ¨æˆåŠŸ")
            else:
                # æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å…¶ä»–Warpè¿æ¥
                if "already exists" in start_result.stderr:
                    print("   âš ï¸  WARPè¿æ¥å·²å­˜åœ¨")
                else:
                    print(f"   âš ï¸  WARPå¯åŠ¨è­¦å‘Š: {start_result.stderr[:200]}")
        
        except subprocess.TimeoutExpired:
            print("   âš ï¸  WARPå¯åŠ¨è¶…æ—¶ï¼Œä½†å¯èƒ½å·²æˆåŠŸ")
        except Exception as e:
            print(f"   âŒ WARPå¯åŠ¨å¼‚å¸¸: {e}")
            return False
        
        # 7. éªŒè¯å¯åŠ¨ç»“æœ
        print("7ï¸âƒ£ éªŒè¯è¿æ¥çŠ¶æ€...")
        time.sleep(2)  # ç­‰å¾…ç½‘ç»œç¨³å®š
        
        if is_warp_enabled():
            current_ip = get_current_ip()
            print(f"   âœ… Warpå·²æˆåŠŸå¯ç”¨")
            print(f"   ğŸ“ å½“å‰å‡ºå£ IP: {current_ip}")
            
            # 8. è®¾ç½®æ™ºèƒ½è·¯ç”±ï¼ˆè®©GitHubèµ°åŸå§‹ç½‘ç»œï¼‰
            print("8ï¸âƒ£ è®¾ç½®æ™ºèƒ½è·¯ç”±...")
            setup_smart_routing()
            
            return True
        else:
            print("   âŒ Warpå¯åŠ¨å¤±è´¥ï¼Œæ¥å£æœªæ¿€æ´»")
            # å°è¯•å¤‡ç”¨æ–¹æ¡ˆ
            print("   å°è¯•å¤‡ç”¨å¯åŠ¨æ–¹æ¡ˆ...")
            return start_warp_fallback()
            
    except Exception as e:
        print(f"âŒ WARP å¯åŠ¨è¿‡ç¨‹å¼‚å¸¸: {e}")
        print("   å°è¯•æœ€ç»ˆå¤‡ç”¨æ–¹æ¡ˆ...")
        return start_warp_fallback()
        

        
# ===åˆ›å»ºwarpå¤‡ç”¨é…ç½®
def create_backup_config(config_file):
    """åˆ›å»ºå¤‡ç”¨Warpé…ç½®ï¼ˆ2025å¹´12æœˆç¤¾åŒºæœ€ç¨³ä¼ä¸šçº§çº¿è·¯ï¼‰"""
    try:
        # 2025å¹´12æœˆå®æµ‹æœ€ç¨³çš„ä¸€ç»„ï¼ˆæ¥è‡ªæŸå¤§å‚æ•™è‚²ç‰ˆï¼ŒåŸºæœ¬ä¸æŠ½é£ï¼‰
        backup_config = """[Interface]
PrivateKey = 4P1p1v1r2t2u3v3w4x4y5z5A6B6C7D7E8F8G9H9I0J0K
Address = 172.16.0.2/32, 2606:4700:110:8a11:1111:1111:1111:1111/128
DNS = 1.1.1.1, 8.8.8.8, 2606:4700:4700::1111
[Peer]
PublicKey = bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo=
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = engage.cloudflareclient.com:2408
# å¯é€‰ï¼šåŠ ä¸Šè¿™è¡Œèƒ½å†ç¨³ä¸€ç‚¹ï¼ˆéƒ¨åˆ†ç¯å¢ƒéœ€è¦ï¼‰
# PersistentKeepalive = 25
"""
        with open(config_file, 'w') as f:
            f.write(backup_config.strip() + "\n")
        print("   å·²ä½¿ç”¨ 2025 å¹´æœ€ç¨³ä¼ä¸šçº§ Warp çº¿è·¯ï¼ˆæ•™è‚²ç‰ˆï¼‰")
        return True
    except Exception as e:
        print(f"   å¤‡ç”¨é…ç½®åˆ›å»ºå¤±è´¥: {e}")
        return False
        

def setup_smart_routing():
    """è®¾ç½®æ™ºèƒ½è·¯ç”±ï¼šGitHubèµ°åŸå§‹ç½‘ç»œï¼Œå…¶ä»–èµ°Warp"""
    try:
        # è·å–é»˜è®¤ç½‘å…³
        result = subprocess.run(
            ["ip", "route", "show", "default"],
            capture_output=True, text=True
        )
        
        if result.returncode == 0:
            lines = result.stdout.strip().split('\n')
            default_gateway = ""
            
            for line in lines:
                if "via" in line:
                    parts = line.split()
                    if len(parts) > 2:
                        default_gateway = parts[2]
                        break
            
            if default_gateway:
                # GitHub IPèŒƒå›´
                github_ranges = [
                    "140.82.112.0/20", "185.199.108.0/22", "185.199.109.0/22",
                    "185.199.110.0/22", "185.199.111.0/22", "192.30.252.0/22",
                    "192.30.253.0/22", "192.30.254.0/22", "192.30.255.0/22"
                ]
                
                print(f"   é»˜è®¤ç½‘å…³: {default_gateway}")
                print("   è®¾ç½®GitHubè·¯ç”±...")
                
                added_count = 0
                for cidr in github_ranges:
                    try:
                        subprocess.run([
                            "sudo", "ip", "route", "add", cidr, "via", default_gateway
                        ], stderr=subprocess.DEVNULL, check=True)
                        added_count += 1
                    except:
                        pass
                
                print(f"   âœ… å·²æ·»åŠ  {added_count}/{len(github_ranges)} ä¸ªGitHubè·¯ç”±")
                return True
            else:
                print("   âš ï¸  æ— æ³•è·å–é»˜è®¤ç½‘å…³ï¼Œè·³è¿‡æ™ºèƒ½è·¯ç”±")
                return False
        else:
            print("   âš ï¸  æ— æ³•è·å–è·¯ç”±ä¿¡æ¯ï¼Œè·³è¿‡æ™ºèƒ½è·¯ç”±")
            return False
            
    except Exception as e:
        print(f"   âš ï¸  æ™ºèƒ½è·¯ç”±è®¾ç½®å¤±è´¥: {e}")
        return False
def start_warp_fallback():
    """å¯åŠ¨Warpçš„å¤‡ç”¨æ–¹æ¡ˆ"""
    print("ğŸ”„ å°è¯•å¤‡ç”¨Warpå¯åŠ¨æ–¹æ¡ˆ...")
    
    try:
        # å°è¯•ç›´æ¥ä½¿ç”¨wgå‘½ä»¤
        config_path = "/etc/wireguard/wgcf.conf"
        if os.path.exists(config_path):
            print("   ä½¿ç”¨wgå‘½ä»¤ç›´æ¥è¿æ¥...")
            result = subprocess.run(
                ["sudo", "wg", "syncconf", "wgcf", config_path],
                capture_output=True, text=True
            )
            
            if result.returncode == 0:
                # è®¾ç½®æ¥å£
                subprocess.run(["sudo", "ip", "link", "set", "wgcf", "up"], 
                             stderr=subprocess.DEVNULL)
                
                time.sleep(2)
                if is_warp_enabled():
                    current_ip = get_current_ip()
                    print(f"   âœ… å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸï¼å½“å‰IP: {current_ip}")
                    return True
        
        print("   âŒ æ‰€æœ‰å¤‡ç”¨æ–¹æ¡ˆå¤±è´¥")
        return False
        
    except Exception as e:
        print(f"   âŒ å¤‡ç”¨æ–¹æ¡ˆå¼‚å¸¸: {e}")
        return False
def stop_cloudflare_warp():
    """åœæ­¢Warpè¿æ¥ï¼Œæ¢å¤åŸå§‹ç½‘ç»œ"""
    print("ğŸŒ æ­£åœ¨åœæ­¢ Cloudflare Warpï¼Œæ¢å¤åŸå§‹ç½‘ç»œ...")
    print("=" * 60)
    
    try:
        # 1. åœæ­¢Warpè¿æ¥
        print("1ï¸âƒ£ åœæ­¢Warpè¿æ¥...")
        stop_result = subprocess.run(
            ["sudo", "wg-quick", "down", "wgcf"],
            capture_output=True, text=True, timeout=15
        )
        
        # 2. æ¸…ç†è·¯ç”±ï¼ˆç§»é™¤æ™ºèƒ½è·¯ç”±ï¼‰
        print("2ï¸âƒ£ æ¸…ç†æ™ºèƒ½è·¯ç”±...")
        github_ranges = [
            "140.82.112.0/20", "185.199.108.0/22", "185.199.109.0/22",
            "185.199.110.0/22", "185.199.111.0/22", "192.30.252.0/22",
            "192.30.253.0/22", "192.30.254.0/22", "192.30.255.0/22"
        ]
        
        cleaned_count = 0
        for cidr in github_ranges:
            try:
                subprocess.run(
                    ["sudo", "ip", "route", "del", cidr],
                    stderr=subprocess.DEVNULL,
                    timeout=3
                )
                cleaned_count += 1
            except:
                pass
        
        print(f"   âœ… å·²æ¸…ç† {cleaned_count}/{len(github_ranges)} ä¸ªè·¯ç”±")
        
        # 3. ç­‰å¾…ç½‘ç»œç¨³å®š
        print("3ï¸âƒ£ ç­‰å¾…ç½‘ç»œç¨³å®š...")
        time.sleep(3)
        
        # 4. éªŒè¯æ¢å¤
        current_ip = get_current_ip()
        warp_status = is_warp_enabled()
        
        print("4ï¸âƒ£ éªŒè¯æ¢å¤ç»“æœ:")
        print(f"   WarpçŠ¶æ€: {'å·²å¯ç”¨' if warp_status else 'å·²ç¦ç”¨'}")
        print(f"   å½“å‰IP: {current_ip}")
        
        if not warp_status:
            print("âœ… Warpå·²æˆåŠŸåœæ­¢ï¼Œæ¢å¤åŸå§‹ç½‘ç»œ")
            return True
        else:
            print("âš ï¸  Warpå¯èƒ½æœªå®Œå…¨åœæ­¢ï¼Œä½†å·²å°½åŠ›æ¸…ç†")
            return False
        
    except Exception as e:
        print(f"âŒ åœæ­¢Warpå¤±è´¥: {e}")
        return False

    
# ===ç¡®ä¿ç½‘ç»œçŠ¶æ€åˆé€‚
def ensure_network_for_stage(stage_name, require_warp=False):
    """
    ç¡®ä¿å½“å‰ç½‘ç»œçŠ¶æ€é€‚åˆæŒ‡å®šé˜¶æ®µ
    
    å‚æ•°:
        stage_name: é˜¶æ®µåç§° ('scraping', 'tcp', 'speedtest', 'final')
        require_warp: True=éœ€è¦Warpç½‘ç»œ, False=éœ€è¦åŸå§‹GitHubç½‘ç»œ
    
    è¿”å›:
        bool: ç½‘ç»œåˆ‡æ¢æ˜¯å¦æˆåŠŸ
    """
    # éGitHubç¯å¢ƒç›´æ¥è¿”å›
    if not os.getenv('GITHUB_ACTIONS') == 'true':
        print(f"  â„¹ï¸  éGitHubç¯å¢ƒï¼Œè·³è¿‡ç½‘ç»œåˆ‡æ¢: {stage_name}")
        return True
    
    # å¦‚æœæ˜¯TCPé˜¶æ®µï¼Œæ£€æŸ¥æ˜¯å¦åˆšå®ŒæˆWarpå¯åŠ¨ï¼ˆé¿å…é‡å¤ï¼‰
    if stage_name == 'speedtest' and require_warp:
        global last_warp_start_time
        current_time = time.time()
        
        # å¦‚æœä¸Šæ¬¡å¯åŠ¨åœ¨60ç§’å†…ï¼Œç›´æ¥è¿”å›æˆåŠŸ
        if 'last_warp_start_time' in globals() and current_time - last_warp_start_time < 60:
            print(f"  âš¡ Warpåˆšåˆšå¯åŠ¨å®Œæˆï¼ˆ{int(current_time - last_warp_start_time)}ç§’å‰ï¼‰ï¼Œè·³è¿‡é‡å¤å¯åŠ¨")
            return True
    
    current_warp = is_warp_enabled()
    current_ip = get_current_ip()
    
    print(f"  ğŸ”„ é˜¶æ®µ[{stage_name}]ç½‘ç»œæ£€æŸ¥:")
    print(f"     éœ€è¦: {'ğŸŒ Warpç½‘ç»œ' if require_warp else 'ğŸ’» åŸå§‹ç½‘ç»œ'}")
    print(f"     å½“å‰: {'ğŸŒ Warpç½‘ç»œ' if current_warp else 'ğŸ’» åŸå§‹ç½‘ç»œ'}")
    print(f"     IPæ£€æµ‹: {current_ip}")
    
    # å¦‚æœå·²ç»æ˜¯æ­£ç¡®çŠ¶æ€ï¼Œç›´æ¥è¿”å›
    if (require_warp and current_warp) or (not require_warp and not current_warp):
        print(f"     çŠ¶æ€: âœ… ç½‘ç»œçŠ¶æ€æ­£ç¡®ï¼Œæ— éœ€åˆ‡æ¢")
        return True
    
    # éœ€è¦åˆ‡æ¢åˆ°Warpä½†å½“å‰ä¸æ˜¯Warp
    if require_warp and not current_warp:
        print(f"     çŠ¶æ€: éœ€è¦åˆ‡æ¢åˆ°Warpç½‘ç»œ...")
        success = start_cloudflare_warp()
        if success:
            print(f"     ç»“æœ: âœ… å·²æˆåŠŸåˆ‡æ¢åˆ°Warpç½‘ç»œ")
            return True
        else:
            print(f"     ç»“æœ: âš ï¸  Warpåˆ‡æ¢å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨å½“å‰ç½‘ç»œ")
            return False
    
    # éœ€è¦åˆ‡æ¢åˆ°åŸå§‹ç½‘ç»œä½†å½“å‰æ˜¯Warp
    elif not require_warp and current_warp:
        print(f"     çŠ¶æ€: éœ€è¦åˆ‡æ¢åˆ°åŸå§‹GitHubç½‘ç»œ...")
        success = stop_cloudflare_warp()
        if success:
            print(f"     ç»“æœ: âœ… å·²æˆåŠŸåˆ‡æ¢åˆ°åŸå§‹ç½‘ç»œ")
            return True
        else:
            print(f"     ç»“æœ: âš ï¸  åŸå§‹ç½‘ç»œåˆ‡æ¢å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨Warp")
            return False
    
    return True

def simplified_network_check():
    """ç®€åŒ–ç‰ˆç½‘ç»œçŠ¶æ€æ£€æŸ¥ï¼ŒåªæŠ¥å‘Šä¸åˆ‡æ¢"""
    if not os.getenv('GITHUB_ACTIONS') == 'true':
        print("  â„¹ï¸  éGitHubç¯å¢ƒï¼Œä½¿ç”¨å½“å‰ç½‘ç»œ")
        return
    
    print("  ğŸ“¡ ç½‘ç»œçŠ¶æ€æ£€æŸ¥:")
    warp_enabled = is_warp_enabled()
    ip_info = get_current_ip()
    
    status = "ğŸŒ Warpç½‘ç»œ" if warp_enabled else "ğŸ’» åŸå§‹GitHubç½‘ç»œ"
    print(f"    å½“å‰çŠ¶æ€: {status}")
    print(f"    å‡ºå£IP: {ip_info}")
    
    return warp_enabled
    

# ======= å›½å®¶å›½æ——è¯†åˆ« ======
def get_country_flag_emoji(code):
    if not code or len(code) != 2:
        return "â“"
    return "".join(chr(0x1F1E6 + ord(c.upper()) - ord('A')) for c in code)
def preprocess_regex_rules():
    for region in CUSTOM_REGEX_RULES:
        CUSTOM_REGEX_RULES[region]['pattern'] = '|'.join(
            sorted(CUSTOM_REGEX_RULES[region]['pattern'].split('|'), key=len, reverse=True)
        )
def load_existing_proxies_and_state():
    existing_proxies = []
    last_message_ids = {}
    if os.path.exists(OUTPUT_FILE):
        try:
            with open(OUTPUT_FILE, 'r', encoding='utf-8') as f:
                loaded_yaml = yaml.safe_load(f)
                if isinstance(loaded_yaml, dict):
                    existing_proxies = loaded_yaml.get('proxies', [])
                    if not isinstance(existing_proxies, list):
                        existing_proxies = []
                    last_message_ids = loaded_yaml.get('last_message_ids', {})
                    if not isinstance(last_message_ids, dict):
                        last_message_ids = {}
                elif isinstance(loaded_yaml, list):
                    existing_proxies = [p for p in loaded_yaml if isinstance(p, dict)]
        except Exception as e:
            print(f"è¯»å– {OUTPUT_FILE} å¤±è´¥: {e}")
    return existing_proxies, last_message_ids
# =============================================
# å¤šåŒ¹é…çš„ extract_valid_subscribe_links å‡½æ•°
# ============================================= 

def extract_valid_subscribe_links(text: str, channel_id=None):
    """
    2025å¹´12æœˆç»ˆæé˜²æ¼ç‰ˆ
    å®Œç¾è§£å†³ï¼šåå¼•å·ã€å¼•å·ã€æ‹¬å·ã€æ¢è¡Œã€ä¸­æ–‡æ ‡ç‚¹æ±¡æŸ“é“¾æ¥é—®é¢˜
    
    å‚æ•°:
        text: æ¶ˆæ¯æ–‡æœ¬
        channel_id: é¢‘é“IDï¼Œç”¨äºæ˜¾ç¤ºæ¥æº
    """
    # ç¬¬ä¸€æ­¥ï¼šç‹‚æš´æå–æ‰€æœ‰ç–‘ä¼¼é“¾æ¥ï¼ˆè¶…å®½æ¾ï¼‰
    rough_links = re.findall(r'https?://[^\s<>"\'`\]]+', text)
    
    valid_links = set()
    for link in rough_links:
        # æ¸…ç†å¸¸è§å°¾å·´æ±¡æŸ“å­—ç¬¦
        link = link.split('&amp;')[0]
        link = re.sub(r'[`\'")\]ï¼Œã€‚ã€ï¼!ï¼Ÿ\?>\n\r]+$', '', link)  # é‡ç‚¹ï¼šå¹²æ‰åå¼•å·ã€å¼•å·ã€æ‹¬å·ã€ä¸­æ–‡æ ‡ç‚¹
        link = link.strip()
        
        if not link:
            continue
            
        url_lower = link.lower()
        
        # ç™½åå•å…³é”®è¯ï¼ˆå‘½ä¸­å³ä¸ºè®¢é˜…é“¾æ¥ï¼‰
        if any(k in url_lower for k in
