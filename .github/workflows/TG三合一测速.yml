name: 🈴 TG抓取节点三合一测速版 v2.0
# ==================== 触发条件配置 ====================
on:
  # 定时执行配置，每4小时10分钟执行一次（例如00:10, 04:10, 08:10...）
  schedule:
    - cron: '20 */4 * * *'
  # 支持手动触发工作流，附带输入参数
  workflow_dispatch:
    inputs:
      # 网络配置模式选择
      warp_config:
        description: '选择网络配置模式'
        required: false
        default: 'default'
        type: choice
        options:
          - default        # 默认配置
          - all_warp       # 全流程使用Warp网络
          - all_github     # 全流程使用GitHub网络
          - test_mode      # 测试模式：仅抓取部分频道，使用Warp测速
      # 是否强制重新下载工具（忽略缓存）
      force_download:
        description: '强制重新下载工具（忽略缓存）'
        required: false
        default: false
        type: boolean
      # 测速模式选择（支持6种，详见说明）
      speedtest_mode:
        description: '选择测速模式'
        required: false
        default: 'tcp_first'
        type: choice
        options:
          - tcp_clash_xc     # TCP 粗筛 → Clash 精测 → Speedtest 精测
          - tcp_clash        # TCP 粗筛 → Clash 精测
          - tcp_xc           # TCP 粗筛 → Speedtest 精测
          - tcp_only         # 纯 TCP 测速
          - clash_only       # 纯 Clash 测验
          - xcspeedtest_only # 纯 Speedtest 测验（xcspeedtest）
# ==================== 环境变量配置 ====================
env:
  # ==================== 版本配置 ====================
  MIHOMO_VERSION: v1.19.17           # Mihomo (Clash Meta) 版本
  SPEEDTEST_VERSION: v0.4.1          # XC Speedtest 版本
  WGCF_VERSION: v2.2.29              # WGCF (Cloudflare Warp) 版本
  CLASH_SPEEDTEST_VERSION: v1.7.0    # Clash-speedtest 核心版本
  # ==================== 网络控制配置 默认网络配置====================
  # 这些变量是Python脚本的唯一控制源，控制各阶段是否使用Warp网络
  # true=使用Warp网络，false=使用原始GitHub网络
  
  # 抓取阶段：使用GitHub网络（速度快）
  WARP_FOR_SCRAPING: "false"
  # TCP测速阶段：使用Warp网络（模拟国内环境，测速结果更准确）
  WARP_FOR_TCP: "true"
  # Speedtest测速阶段：使用Warp网络（模拟国内环境，测速结果更准确）
  WARP_FOR_SPEEDTEST: "true"
  # 最终处理阶段：使用GitHub网络（确保提交等操作正常）
  WARP_FOR_FINAL: "false"
  
  # ==================== 测速策略配置 ====================
  # 测速模式选项：
  #   tcp_clash_xc  → TCP 粗筛 → Clash 精测 → Speedtest 精测（推荐）
  #   tcp_clash     → TCP 粗筛 → Clash 精测
  #   tcp_xc        → TCP 粗筛 → Speedtest 精测
  #   tcp_only      → 纯 TCP 测速（最快，最适合节点特别多的情况）
  #   clash_only    → 纯 Clash 测速（最准）
  #   xcspeedtest_only → 纯 xcspeedtest 测速
  #SPEEDTEST_MODE: "tcp_first"       # 兼容原有配置，推荐使用 DETAILED_SPEEDTEST_MODE 覆盖；已删除
  DETAILED_SPEEDTEST_MODE: "tcp_clash_xc"       # 默认模式，覆盖全部测速选择：tcp_clash_xc, tcp_clash, tcp_xc, tcp_only, clash_only, xcspeedtest_only
 
  # ==================== 带宽筛选配置 ====================
  # 是否启用带宽筛选（True=启用，False=关闭），通过环境变量控制
  ENABLE_BANDWIDTH_FILTER: "true"
  # 最低带宽阈值（单位：MB/s），默认为20MB/s
  MIN_BANDWIDTH_MB: "20"
  # ==================== 日志配置 ====================
  # 是否启用TCP测速详细日志（生产环境建议关闭）
  ENABLE_TCP_LOG: "false"
  # 是否启用Speedtest测速详细日志（生产环境建议关闭） # false不开启，true开启
  ENABLE_SPEEDTEST_LOG: "false"
  # ==================== Telegram频道配置 ====================
  # 要抓取的Telegram频道列表（每行一个）
  # 支持频道ID（如 @channel_name）或频道链接
  TELEGRAM_CHANNEL_IDS: |
    @fqDINYUE
    @wxdy666
    @freeyule
    @ccbaohe
    @duangvpsfs
    @zzzjjjkkkoi
    @xmdexw
    @v2v2clash
    @dingyue_Center
    @tempssrlink
    @sorenab2
    @proxyshareCN
# ==================== 工作流任务定义 ====================
jobs:
  build:
    # 使用最新的Ubuntu运行器
    runs-on: ubuntu-latest
    # 任务超时时间30分钟
    timeout-minutes: 30
    steps:
      # === 步骤1：检出代码仓库 ===
      - name: 检出代码仓库
        uses: actions/checkout@v4
        with:
          # 获取完整历史记录，便于后续提交操作
          fetch-depth: 0
          # 使用GitHub Token认证
          token: ${{ secrets.GITHUB_TOKEN }}
          submodules: false
      # === 步骤2：设置 Python 环境 ===
      - name: 设置 Python 环境
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          # 缓存pip依赖以加速
          cache: 'pip'
          cache-dependency-path: '**/requirements.txt'
      # === 步骤3：缓存 Python 依赖 ===
      - name: 缓存 Python 依赖
        uses: actions/cache@v4
        id: cache-pip
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      # === 步骤4：安装 Python 依赖及系统依赖 ===
      - name: 安装 Python 依赖及系统依赖
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          sudo apt-get update -qq
          sudo apt-get install -y wireguard-tools curl resolvconf wget
      # === 步骤5：缓存 Mihomo 程序 ===
      - name: 缓存 Mihomo 程序
        id: cache-mihomo
        uses: actions/cache@v4
        with:
          path: mihomo
          key: mihomo-amd64-${{ env.MIHOMO_VERSION }}
          restore-keys: mihomo-amd64-${{ env.MIHOMO_VERSION }}
      # === 步骤6：下载 Mihomo 指定版本 ===
      - name: 下载 Mihomo 指定版本
        if: steps.cache-mihomo.outputs.cache-hit != 'true' || inputs.force_download == 'true'
        run: |
          set -e
          TAG=${{ env.MIHOMO_VERSION }}
          URL="https://github.com/MetaCubeX/mihomo/releases/download/${TAG}/mihomo-linux-amd64-${TAG}.gz"
          echo "尝试访问下载链接: $URL"
          if ! curl --head --fail "$URL"; then
            echo "❌ 错误：下载地址不可用！"
            exit 1
          fi
          wget --tries=3 --timeout=30 -O mihomo.gz "$URL"
          gunzip -f mihomo.gz
          chmod +x mihomo
          ./mihomo -v
      # === 步骤7：缓存 wgcf 工具 ===
      - name: 缓存 wgcf 工具
        id: cache-wgcf
        uses: actions/cache@v4
        with:
          path: wgcf
          key: wgcf-linux-amd64-${{ env.WGCF_VERSION }}
          restore-keys: wgcf-linux-amd64-${{ env.WGCF_VERSION }}
      # === 步骤8：下载 wgcf 工具 ===
      - name: 下载 wgcf 工具
        if: steps.cache-wgcf.outputs.cache-hit != 'true' || inputs.force_download == 'true'
        run: |
          WGCF_FULL_VERSION="${{ env.WGCF_VERSION }}"
          WGCF_FILENAME_VERSION="${WGCF_FULL_VERSION#v}"
          echo "正在下载 wgcf v${WGCF_FILENAME_VERSION}..."
          curl -fsSL -o wgcf "https://github.com/ViRb3/wgcf/releases/download/${WGCF_FULL_VERSION}/wgcf_${WGCF_FILENAME_VERSION}_linux_amd64"
          if [ ! -f "wgcf" ]; then
            echo "❌ 错误：wgcf 下载失败！"
            exit 1
          fi
          chmod +x wgcf
          echo "wgcf 下载完成。"
      # === 步骤9：缓存 xcspeedtest 程序 ===
      - name: 缓存 xiecang speedtest-clash
        id: cache-xc
        uses: actions/cache@v4
        with:
          path: xcspeedtest
          key: xiecang-${{ env.SPEEDTEST_VERSION }}
          restore-keys: xiecang-${{ env.SPEEDTEST_VERSION }}
      # === 步骤10：下载 xcspeedtest ===
      - name: 下载 xiecang speedtest-clash
        if: steps.cache-xc.outputs.cache-hit != 'true' || inputs.force_download == 'true'
        run: |
          set -e
          RELEASE_TAG=${{ env.SPEEDTEST_VERSION }}
          echo "尝试下载 speedtest-clash 版本: $RELEASE_TAG"
          URL=$(curl -s "https://api.github.com/repos/xiecang/speedtest-clash/releases/tags/${RELEASE_TAG}" \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          if [ -z "$URL" ]; then
            echo "⚠️ 警告: 未找到指定版本 (${RELEASE_TAG})，尝试最新版本。"
            URL=$(curl -s https://api.github.com/repos/xiecang/speedtest-clash/releases/latest \
                | grep "browser_download_url.*speedtest-clash_Linux_x86_64" | cut -d '"' -f4)
          fi
          if [ -z "$URL" ]; then
            echo "❌ 错误：未能找到 speedtest-clash 下载 URL，退出。"
            exit 1
          fi
          wget --tries=5 --timeout=60 -O downloaded_file "$URL"
          if file downloaded_file | grep -q "gzip compressed data"; then
            echo "检测到压缩包，开始解压"
            tar -xzf downloaded_file
            if [ -f "speedtest-clash" ]; then
              mv speedtest-clash xcspeedtest
            else
              EXE_PATH=$(find . -maxdepth 1 -type f -executable -name "speedtest-clash*" -print -quit)
              if [ -n "$EXE_PATH" ]; then
                mv "$EXE_PATH" xcspeedtest
              else
                echo "❌ 错误：未找到 speedtest-clash 可执行文件"
                exit 1
              fi
            fi
            rm downloaded_file
          else
            echo "下载的是可执行文件，直接重命名为 xcspeedtest"
            mv downloaded_file xcspeedtest
          fi
          chmod +x xcspeedtest
          ./xcspeedtest --help
      # === 步骤11：缓存 clash-speedtest 核心 ===
      - name: 缓存 clash-speedtest 核心 (clash_core/)
        id: cache-clash-speedtest
        uses: actions/cache@v4
        with:
          path: clash_core/
          key: ${{ runner.os }}-clash-speedtest-${{ env.CLASH_SPEEDTEST_VERSION }}
      # === 步骤12：下载并解压 clash-speedtest 核心 ===
      - name: 下载并解压 clash-speedtest 到 clash_core/clash
        if: steps.cache-clash-speedtest.outputs.cache-hit != 'true' || inputs.force_download == 'true'
        run: |
          mkdir -p clash_core
          URL="https://github.com/faceair/clash-speedtest/releases/download/${{ env.CLASH_SPEEDTEST_VERSION }}/clash-speedtest_Linux_x86_64.tar.gz"
          echo "正在下载 clash-speedtest 核心..."
          wget -q -O clash-speedtest.tar.gz "$URL"
          tar -xzf clash-speedtest.tar.gz -C clash_core
          rm -f clash-speedtest.tar.gz
          mv clash_core/clash-speedtest clash_core/clash
          chmod +x clash_core/clash
          echo "clash-speedtest 下载并解压完成。"
      # === 步骤13：智能网络配置 + 运行测速脚本 ===
      - name: 智能网络配置 + 运行测速脚本
        env:
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_STRING_SESSION: ${{ secrets.TELEGRAM_STRING_SESSION }}
          GITHUB_ACTIONS: "true"
          PYTHONUNBUFFERED: "1"
          WARP_FOR_SCRAPING: ${{ env.WARP_FOR_SCRAPING }}
          WARP_FOR_TCP: ${{ env.WARP_FOR_TCP }}
          WARP_FOR_SPEEDTEST: ${{ env.WARP_FOR_SPEEDTEST }}
          WARP_FOR_FINAL: ${{ env.WARP_FOR_FINAL }}
          SPEEDTEST_MODE: ${{ env.SPEEDTEST_MODE }}
          DETAILED_SPEEDTEST_MODE: ${{ env.DETAILED_SPEEDTEST_MODE }}
          TELEGRAM_CHANNEL_IDS: ${{ env.TELEGRAM_CHANNEL_IDS }}
          ENABLE_BANDWIDTH_FILTER: ${{ env.ENABLE_BANDWIDTH_FILTER }}
          MIN_BANDWIDTH_MB: ${{ env.MIN_BANDWIDTH_MB }}
          ENABLE_TCP_LOG: ${{ env.ENABLE_TCP_LOG }}
          ENABLE_SPEEDTEST_LOG: ${{ env.ENABLE_SPEEDTEST_LOG }}
        run: |
          echo "=== 开始执行节点抓取和测速脚本 ==="
          mkdir -p flclashyaml
          python TelegramNode/TBD-telegram_publiclink1.py
          EXIT_CODE=$?
          if [ $EXIT_CODE -eq 0 ]; then
            echo "✅ 节点抓取和测速完成"
            if [ -f "flclashyaml/Tg-node2.yaml" ]; then
              FILE_SIZE=$(stat -c%s "flclashyaml/Tg-node2.yaml" 2>/dev/null || stat -f%z "flclashyaml/Tg-node2.yaml" 2>/dev/null || echo "unknown")
              echo "📁 配置文件生成成功: flclashyaml/Tg-node2.yaml (${FILE_SIZE} bytes)"
            else
              echo "⚠️  配置文件未生成"
            fi
          else
            echo "❌ Python脚本执行失败，退出码: $EXIT_CODE"
            exit $EXIT_CODE
          fi
      # === 步骤14：确保网络正常（重要修复）===
      - name: 确保网络正常
        if: always()
        run: |
          echo "=== 🔧 确保网络正常 ==="
          echo "1️⃣ 停止任何Warp连接..."
          sudo wg-quick down wgcf 2>/dev/null || echo "   ℹ️ WARP未运行"
          sudo ip link delete wgcf 2>/dev/null || echo "   ℹ️ 接口不存在"
          
          echo "2️⃣ 清除Warp相关路由..."
          for cidr in \
            "140.82.112.0/20" "185.199.108.0/22" "185.199.109.0/22" \
            "185.199.110.0/22" "185.199.111.0/22" "192.30.252.0/22" \
            "192.30.253.0/22" "192.30.254.0/22" "192.30.255.0/22"; do
            sudo ip route del $cidr 2>/dev/null || true
          done
          echo "3️⃣ 测试网络连接..."
          CURRENT_IP=""
          for server in "https://ip.sb" "https://api.ipify.org" "https://checkip.amazonaws.com" "https://ipinfo.io/ip"; do
            if CURRENT_IP=$(curl -4 -s --max-time 5 "$server" | grep -E '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'); then
              echo "   ✅ 成功: $CURRENT_IP (来自 $server)"
              break
            fi
          done
          if [ -z "$CURRENT_IP" ]; then
            CURRENT_IP=$(hostname -I | awk '{print $1}' 2>/dev/null || echo "unknown")
            echo "   ℹ️ 备用IP: $CURRENT_IP"
          fi
          echo "4️⃣ 检查GitHub连接..."
          if curl -I --silent --max-time 10 https://github.com 2>/dev/null | head -1; then
            echo "   ✅ GitHub连接正常"
          else
            echo "   ⚠️  GitHub连接可能有问题"
          fi
          echo "=== 网络检查完成 ==="
      # === 步骤15：自动提交更改，强制覆盖远程分支 ===
      - name: 自动提交更改
        if: success()
        run: |
          echo "=== 📤 自动提交更改 ==="
          echo "提交时间: $(date '+%Y-%m-%d %H:%M:%S %Z')"
          if [ ! -f "flclashyaml/Tg-node2.yaml" ]; then
            echo "⚠️ 配置文件不存在，跳过提交"
            exit 0
          fi

          # 同步远程 master 分支，保持最新代码
          git fetch origin master
          git reset --hard origin/master

          if ! git diff --quiet flclashyaml/Tg-node2.yaml 2>/dev/null; then
            git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add flclashyaml/Tg-node2.yaml
            COMMIT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            NODE_COUNT=$(python3 -c 'import yaml; d=yaml.safe_load(open("flclashyaml/Tg-node2.yaml",encoding="utf-8")); print(len(d.get("proxies",[])))' 2>/dev/null || echo "?")
            COMMIT_MESSAGE="🚀 自动更新：Telegram节点配置 (${NODE_COUNT}节点) - ${COMMIT_TIME}"
            echo "提交信息: ${COMMIT_MESSAGE}"
            git commit -m "${COMMIT_MESSAGE}"
            # 强制推送，覆盖远程分支
            git push origin HEAD --force
            echo "✅ 强制提交完成"
          else
            echo "📝 文件无变化，跳过提交"
          fi
